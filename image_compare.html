<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Image Compare</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üîç</text></svg>">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #1a1a1a;
  color: #fff;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  height: 100vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}
#dropzone {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 3px dashed #444;
  margin: 20px;
  border-radius: 12px;
  transition: border-color 0.2s, background 0.2s;
}
#dropzone.dragover {
  border-color: #0af;
  background: rgba(0, 170, 255, 0.1);
}
#dropzone.hidden { display: none; }
.drop-text {
  text-align: center;
  color: #888;
}
.drop-text h2 { font-size: 24px; margin-bottom: 10px; }
.drop-text p { font-size: 14px; }

#viewer {
  display: none;
  flex: 1;
  position: relative;
  overflow: hidden;
  cursor: grab;
}
#viewer.active { display: block; }
#viewer.dragging { cursor: grabbing; }

#canvas {
  position: absolute;
  top: 50%;
  left: 50%;
  transform-origin: center center;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}

#thumbnail {
  position: absolute;
  top: 10px;
  right: 10px;
  background: rgba(0, 0, 0, 0.7);
  border: 1px solid #444;
  border-radius: 4px;
  padding: 4px;
  display: none;
}
#thumbnail.active { display: block; }
#thumb-canvas {
  display: block;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}
#thumb-viewport {
  position: absolute;
  border: 2px solid #f0f;
  pointer-events: none;
  box-sizing: border-box;
}

#info {
  background: #2a2a2a;
  padding: 6px 12px;
  display: flex;
  align-items: center;
  font-size: 13px;
  flex-shrink: 0;
  min-height: 36px;
  gap: 12px;
}
#info.hidden { display: none; }
#modality-selector {
  display: flex;
  gap: 2px 4px;
  flex-wrap: wrap;
  align-items: center;
  align-content: center;
  min-width: 0;
}
#status {
  color: #888;
  flex: 1;
  min-width: 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 16px;
  line-height: 1.2;
}
#status-name {
  flex: 1;
  text-align: left;
  word-break: break-all;
}
#status-info {
  flex-shrink: 0;
  text-align: right;
  white-space: nowrap;
}
.modality-btn {
  display: inline-flex;
  align-items: center;
  padding: 4px 10px;
  border-radius: 4px;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: opacity 0.15s, transform 0.15s;
  border: none;
  color: #000;
  user-select: none;
  position: relative;
  flex-shrink: 0;
}
.modality-btn:hover {
  transform: scale(1.05);
}
.modality-btn.active {
  opacity: 1;
  box-shadow: 0 0 0 2px #fff;
}
.modality-btn.inactive {
  opacity: 0.4;
}
.modality-btn.unavailable {
  opacity: 0.5;
  text-decoration: line-through;
}
.modality-btn.unavailable.active {
  opacity: 0.7;
}
#help-btn {
  background: #444;
  color: #fff;
  width: 24px;
  height: 24px;
  padding: 0;
  border-radius: 50%;
  font-size: 14px;
  font-weight: bold;
  cursor: pointer;
  border: none;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}
#help-btn:hover {
  background: #555;
}
.reorder-btn {
  background: #444;
  color: #fff;
  width: 24px;
  height: 24px;
  padding: 0;
  border-radius: 4px;
  font-size: 14px;
  cursor: pointer;
  border: none;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}
.reorder-btn:hover {
  background: #555;
}
.reorder-btn:disabled {
  opacity: 0.3;
  cursor: default;
}
#reorder-buttons {
  display: flex;
  gap: 2px;
  flex-shrink: 0;
  align-items: center;
}
#help-modal {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.8);
  align-items: center;
  justify-content: center;
  z-index: 100;
}
#help-modal.active { display: flex; }
#help-modal .modal-content {
  max-width: 450px;
}
#help-modal h3 {
  color: #0af;
  margin-bottom: 15px;
}
#help-modal table {
  width: 100%;
  text-align: left;
  border-collapse: collapse;
}
#help-modal td {
  padding: 6px 8px;
  border-bottom: 1px solid #444;
}
#help-modal td:first-child {
  color: #0af;
  font-family: monospace;
  white-space: nowrap;
}

/* Progress bar */
#progress-container {
  position: absolute;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.8);
  border: 1px solid #444;
  border-radius: 8px;
  padding: 12px 20px;
  z-index: 50;
  display: none;
  min-width: 250px;
  text-align: center;
}
#progress-container.active { display: block; }
#progress-text {
  margin-bottom: 8px;
  font-size: 12px;
  color: #aaa;
}
#progress-bar {
  width: 100%;
  height: 6px;
  background: #333;
  border-radius: 3px;
  overflow: hidden;
}
#progress-fill {
  height: 100%;
  background: #0af;
  width: 0%;
  transition: width 0.1s;
}

/* Carousel styles */
#carousel {
  display: none;
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.85);
  border-right: 1px solid #333;
  overflow-y: auto;
  overflow-x: hidden;
  z-index: 10;
  scroll-behavior: auto;  /* Prevent smooth scroll during resize */
}
#carousel.active { display: block; }
#carousel.resizing .carousel-row,
#carousel.resizing .carousel-thumb {
  transition: none !important;  /* Disable transitions during resize */
}
#carousel::-webkit-scrollbar {
  width: 6px;
}
#carousel::-webkit-scrollbar-track {
  background: #1a1a1a;
}
#carousel::-webkit-scrollbar-thumb {
  background: #444;
  border-radius: 3px;
}
#carousel::-webkit-scrollbar-thumb:hover {
  background: #555;
}
.carousel-row {
  display: flex;
  gap: 2px;
  padding: 4px 6px;
  cursor: pointer;
  border-bottom: 1px solid #222;
  transition: background 0.15s;
}
.carousel-row:hover {
  background: rgba(255, 255, 255, 0.05);
}
.carousel-row.current {
  background: rgba(255, 255, 255, 0.1);
}
.carousel-thumb {
  object-fit: contain;
  background: #111;
  border-radius: 3px;
  border: 2px solid transparent;
  transition: border-color 0.15s, opacity 0.15s;
  opacity: 0.6;
  flex-shrink: 0;
}
.carousel-thumb:hover {
  opacity: 1;
}
.carousel-thumb.active {
  opacity: 1;
}
.carousel-thumb.selected {
  border-color: #f0f;
}
.carousel-thumb.placeholder {
  background: #1a1a1a;
  opacity: 0.5;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border: 2px solid #333;
}
.carousel-thumb.placeholder:hover {
  opacity: 0.7;
  border-color: #555;
}
.carousel-thumb.placeholder.selected {
  border-color: #f0f;
  opacity: 0.8;
}
.carousel-thumb.placeholder::after {
  content: '‚úï';
  color: #555;
  font-size: 18px;
  font-weight: bold;
}

/* Winner voting indicators */
.carousel-thumb-container {
  position: relative;
  flex-shrink: 0;
}
.winner-indicator {
  position: absolute;
  top: 2px;
  right: 2px;
  width: 7px;
  height: 7px;
  background: rgba(255, 255, 255, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.4);
  cursor: pointer;
  transition: all 0.15s;
  z-index: 5;
}
.winner-indicator:hover {
  background: rgba(255, 255, 255, 0.4);
  border-color: rgba(255, 255, 255, 0.6);
}
.winner-indicator.winner {
  background: #0f0;
  border-color: #fff;
  box-shadow: 0 0 3px rgba(0, 255, 0, 0.5);
}
.winner-indicator.winner:hover {
  background: #0c0;
  border-color: #fff;
}

/* Carousel resize handle */
#carousel-resize {
  display: none;
  position: absolute;
  left: 216px;  /* CAROUSEL_WIDTH - 4 */
  top: 0;
  bottom: 0;
  width: 8px;
  cursor: ew-resize;
  background: transparent;
  z-index: 11;
}
#carousel-resize.active {
  display: block;
}
#carousel-resize:hover,
#carousel-resize.dragging {
  background: rgba(0, 170, 255, 0.3);
}

#error-modal {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.8);
  align-items: center;
  justify-content: center;
  z-index: 100;
}
#error-modal.active { display: flex; }
.modal-content {
  background: #2a2a2a;
  padding: 30px;
  border-radius: 12px;
  text-align: center;
  max-width: 400px;
}
.modal-content h3 { margin-bottom: 15px; color: #f66; }
.modal-content p { margin-bottom: 20px; line-height: 1.6; }
.modal-buttons { display: flex; gap: 10px; justify-content: center; }
.btn {
  padding: 10px 24px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
}
.btn-primary { background: #0af; color: #000; }
.btn-secondary { background: #444; color: #fff; }
.btn:hover { opacity: 0.9; }
</style>
</head>
<body>

<div id="dropzone">
  <div class="drop-text">
    <h2>Drop 2+ Images or a Folder <span id="dropzone-version" style="font-size: 12px; color: #666; font-weight: normal;"></span></h2>
    <p>Drop multiple images to form a tuple, or a folder with subdirectories as modalities</p>
    <p style="margin-top: 12px;">
      <button id="select-folder-btn" class="btn btn-primary">Select Folder</button>
    </p>
    <p style="margin-top: 20px; color: #666; font-size: 12px; line-height: 1.8;">
      ‚Üê‚Üí: modality | ‚Üë‚Üì: tuple | Space: flip | 1-9: jump to modality<br>
      [ ]: reorder modality | Enter: toggle winner | Scroll: zoom | Drag: pan | Esc: reset
    </p>
  </div>
</div>

<div id="viewer">
  <div id="carousel"></div>
  <div id="carousel-resize"></div>
  <div id="progress-container">
    <div id="progress-text">Loading thumbnails...</div>
    <div id="progress-bar"><div id="progress-fill"></div></div>
  </div>
  <canvas id="canvas"></canvas>
  <div id="thumbnail">
    <canvas id="thumb-canvas"></canvas>
    <div id="thumb-viewport"></div>
  </div>
</div>

<div id="info" class="hidden">
  <div id="reorder-buttons">
    <button id="reorder-left" class="reorder-btn" title="Move modality left ([)">‚Üê</button>
    <button id="reorder-right" class="reorder-btn" title="Move modality right (])">‚Üí</button>
  </div>
  <div id="modality-selector"></div>
  <span id="status"><span id="status-name">Loading...</span><span id="status-info"></span></span>
  <button id="help-btn" title="Keyboard shortcuts">?</button>
</div>

<div id="help-modal">
  <div class="modal-content">
    <h3>Keyboard Shortcuts <span id="help-version" style="font-size: 12px; color: #666; font-weight: normal;"></span></h3>
    <table>
      <tr><td>‚Üê ‚Üí</td><td>Switch modality</td></tr>
      <tr><td>‚Üë ‚Üì</td><td>Previous/next tuple</td></tr>
      <tr><td>Space</td><td>Flip to previous modality (hold)</td></tr>
      <tr><td>1-9</td><td>Jump to modality N</td></tr>
      <tr><td>[ ]</td><td>Reorder current modality</td></tr>
      <tr><td>Enter</td><td>Toggle winner for current modality</td></tr>
      <tr><td>Scroll</td><td>Zoom in/out</td></tr>
      <tr><td>Drag</td><td>Pan image</td></tr>
      <tr><td>Esc</td><td>Reset zoom (2x: back to start)</td></tr>
    </table>
    <div class="modal-buttons" style="margin-top: 20px;">
      <button class="btn btn-primary" onclick="closeHelpModal()">Close</button>
    </div>
  </div>
</div>

<div id="error-modal">
  <div class="modal-content">
    <h3>Aspect Ratio Mismatch</h3>
    <p id="error-text"></p>
    <div class="modal-buttons">
      <button class="btn btn-secondary" onclick="cancelLoad()">Cancel</button>
      <button class="btn btn-primary" onclick="continueLoad()">Continue Anyway</button>
    </div>
  </div>
</div>

<input type="file" id="file-input" accept="image/*" multiple style="display:none">
<input type="file" id="folder-input" webkitdirectory style="display:none">

<script>
// Version
const VERSION = 'v0.1.1';

// Set version in UI
document.getElementById('help-version').textContent = VERSION;
document.getElementById('dropzone-version').textContent = VERSION;

const dropzone = document.getElementById('dropzone');
const viewer = document.getElementById('viewer');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const info = document.getElementById('info');
const status = document.getElementById('status');
const statusName = document.getElementById('status-name');
const statusInfo = document.getElementById('status-info');
const modalitySelector = document.getElementById('modality-selector');
const errorModal = document.getElementById('error-modal');
const errorText = document.getElementById('error-text');
const fileInput = document.getElementById('file-input');
const thumbnail = document.getElementById('thumbnail');
const thumbCanvas = document.getElementById('thumb-canvas');
const thumbCtx = thumbCanvas.getContext('2d');
const thumbViewport = document.getElementById('thumb-viewport');
const carousel = document.getElementById('carousel');
const carouselResize = document.getElementById('carousel-resize');
const progressContainer = document.getElementById('progress-container');
const progressText = document.getElementById('progress-text');
const progressFill = document.getElementById('progress-fill');

const THUMB_MAX_SIZE = 150;
const IMAGE_EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'bmp', 'webp', 'tiff', 'tif', 'ppmx'];

// Configurable carousel width - thumbnails scale proportionally
let CAROUSEL_WIDTH = 220;
let CAROUSEL_THUMB_SIZE = 50;  // Base size, will be recalculated

// Modality colors - cycle through these
const MODALITY_COLORS = [
  '#0f0',    // green
  '#f60',    // orange
  '#0af',    // cyan
  '#f0f',    // magenta
  '#ff0',    // yellow
  '#f44',    // red
  '#4f4',    // light green
  '#44f',    // blue
];

// Current tuple's images - array indexed by modality position
// May contain undefined for missing modalities
let images = [];  // images[modalityIndex] = {img, name, width, height, url, modality} or undefined
let currentModalityIndex = 0;  // Index into modalities array (display position)
let previousModalityIndex = 0;  // For spacebar flip behavior
let zoom = 1;
let panX = 0, panY = 0;
let isDragging = false;
let dragStartX, dragStartY;
let pendingImages = null;
let isReset = false;
let spaceDown = false;

// Multi-tuple mode
let tuples = [];
let currentTupleIndex = 0;
let modalities = [];  // Array of modality names
let modalityColors = [];  // Color assigned to each modality
let isMultiTupleMode = false;

// Winner voting state
let winners = new Map();  // tupleIndex -> modalityIndex
let votingEnabled = false;  // Only enabled in directory mode
let rootDirHandle = null;  // Directory handle for saving results.txt (File System Access API)

// Thumbnail cache: Map of File object -> canvas data URL (file-based key survives reordering)
const thumbnailCache = new WeakMap();

// Preloaded tuples cache: Map of tupleIdx -> loaded images array
const preloadedTuples = new Map();
const PRELOAD_AHEAD = 3;  // Number of tuples to preload ahead/behind

// Help modal
const helpModal = document.getElementById('help-modal');
const helpBtn = document.getElementById('help-btn');

helpBtn.addEventListener('click', () => {
  helpModal.classList.add('active');
});

function closeHelpModal() {
  helpModal.classList.remove('active');
}

// Reorder buttons
const reorderLeftBtn = document.getElementById('reorder-left');
const reorderRightBtn = document.getElementById('reorder-right');

reorderLeftBtn.addEventListener('click', () => moveCurrentModality(-1));
reorderRightBtn.addEventListener('click', () => moveCurrentModality(1));

// Keyboard navigation state
let isLoadingTuple = false;  // Prevent concurrent tuple loads
let lastKeyNavTime = 0;
const KEY_NAV_THROTTLE = 100;  // ms between tuple changes when holding key

// Drag and drop
dropzone.addEventListener('dragover', (e) => {
  e.preventDefault();
  dropzone.classList.add('dragover');
});

dropzone.addEventListener('dragleave', () => {
  dropzone.classList.remove('dragover');
});

dropzone.addEventListener('drop', async (e) => {
  e.preventDefault();
  dropzone.classList.remove('dragover');

  const items = e.dataTransfer.items;
  if (!items) {
    handleFiles(e.dataTransfer.files);
    return;
  }

  // Check if we have directories using the modern File System Access API
  const entries = [];
  for (let i = 0; i < items.length; i++) {
    const entry = items[i].webkitGetAsEntry ? items[i].webkitGetAsEntry() : null;
    if (entry) entries.push({ entry, item: items[i] });
  }

  const dirs = entries.filter(e => e.entry.isDirectory);

  if (dirs.length === 1 && entries.length === 1) {
    // Single directory - check for subdirectories as modalities
    try {
      if (items[0].getAsFileSystemHandle) {
        const handle = await items[0].getAsFileSystemHandle();
        if (handle.kind === 'directory') {
          await handleSingleDirectoryModern(handle);
          return;
        }
      }
    } catch (err) {
      console.warn('Modern API failed, trying legacy:', err);
    }

    // Fallback to legacy API
    try {
      await handleSingleDirectory(dirs[0].entry);
    } catch (err) {
      console.error('Directory handling error:', err);
      alert('Error reading directory. Try using Chrome or select files directly.');
    }
  } else if (dirs.length >= 2) {
    alert('Please drop a single folder with subdirectories as modalities, or multiple image files.');
  } else {
    // Regular files mode - form a single tuple
    handleFiles(e.dataTransfer.files);
  }
});

dropzone.addEventListener('click', (e) => {
  if (e.target.tagName === 'BUTTON') return;
  fileInput.click();
});
fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

// Folder selection via button
const selectFolderBtn = document.getElementById('select-folder-btn');
const folderInput = document.getElementById('folder-input');

selectFolderBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  folderInput.value = '';
  folderInput.click();
});

folderInput.addEventListener('change', async (e) => {
  if (e.target.files.length > 0) {
    await handleFolderInput(e.target.files);
  }
});

async function handleFolderInput(files) {
  // Group files by their immediate parent directory
  const filesByDir = new Map();

  for (const file of files) {
    const pathParts = file.webkitRelativePath.split('/');
    if (pathParts.length < 2) continue;

    // Check if it's in a subdirectory (pathParts.length >= 3 means root/subdir/file)
    if (pathParts.length >= 3) {
      const subdir = pathParts[1];
      if (!filesByDir.has(subdir)) {
        filesByDir.set(subdir, []);
      }
      const ext = file.name.split('.').pop().toLowerCase();
      if (IMAGE_EXTENSIONS.includes(ext)) {
        filesByDir.set(subdir, [...filesByDir.get(subdir), file]);
      }
    }
  }

  if (filesByDir.size < 2) {
    // No subdirectories, treat as single tuple
    const imageFiles = Array.from(files).filter(f => {
      const ext = f.name.split('.').pop().toLowerCase();
      return IMAGE_EXTENSIONS.includes(ext);
    });

    if (imageFiles.length >= 2) {
      await handleFilesAsTuple(imageFiles);
    } else {
      alert('Need at least 2 images or a folder with subdirectories as modalities');
    }
    return;
  }

  // Folder input doesn't provide directory handle for writing
  rootDirHandle = null;
  votingEnabled = false;
  winners = new Map();

  // Process subdirectories as modalities
  await processSubdirectoriesAsModalities(filesByDir);
}

async function handleSingleDirectory(dirEntry) {
  // Read subdirectories
  const subdirs = [];

  await new Promise((resolve, reject) => {
    const reader = dirEntry.createReader();

    function readBatch() {
      reader.readEntries((entries) => {
        if (entries.length === 0) {
          resolve();
          return;
        }
        for (const entry of entries) {
          if (entry.isDirectory) {
            subdirs.push(entry);
          }
        }
        readBatch();
      }, reject);
    }
    readBatch();
  });

  if (subdirs.length < 2) {
    alert('Folder must contain at least 2 subdirectories as modalities');
    return;
  }

  // Read files from each subdirectory
  const filesByDir = new Map();
  for (const subdir of subdirs) {
    const files = await readDirectory(subdir);
    if (files.length > 0) {
      filesByDir.set(subdir.name, files);
    }
  }

  if (filesByDir.size < 2) {
    alert('Need at least 2 subdirectories with images');
    return;
  }

  // Legacy API doesn't support directory handles for writing
  rootDirHandle = null;
  votingEnabled = false;
  winners = new Map();

  await processSubdirectoriesAsModalitiesLegacy(filesByDir);
}

async function handleSingleDirectoryModern(dirHandle) {
  const subdirs = [];

  for await (const entry of dirHandle.values()) {
    if (entry.kind === 'directory') {
      subdirs.push(entry);
    }
  }

  if (subdirs.length < 2) {
    alert('Folder must contain at least 2 subdirectories as modalities');
    return;
  }

  // Read files from each subdirectory
  const filesByDir = new Map();
  for (const subdir of subdirs) {
    const files = await readDirectoryModern(subdir);
    if (files.length > 0) {
      filesByDir.set(subdir.name, files);
    }
  }

  if (filesByDir.size < 2) {
    alert('Need at least 2 subdirectories with images');
    return;
  }

  // Store directory handle for saving results.txt
  rootDirHandle = dirHandle;
  votingEnabled = true;
  winners = new Map();

  await processSubdirectoriesAsModalitiesModern(filesByDir);

  // Load existing winners from results.txt
  await loadResults();
}

async function processSubdirectoriesAsModalities(filesByDir) {
  // Sort modalities alphabetically
  modalities = Array.from(filesByDir.keys()).sort();
  modalityColors = modalities.map((_, i) => MODALITY_COLORS[i % MODALITY_COLORS.length]);

  // Use trie-based matching to group files into tuples
  const matchedTuples = matchTuplesWithTrie(filesByDir, modalities);

  if (matchedTuples.length === 0) {
    alert('No images found in modalities');
    return;
  }

  // Build tuples from matched files
  tuples = [];
  for (const matched of matchedTuples) {
    const tupleImages = [];
    const names = [];

    // Add files in modality order
    for (const modality of modalities) {
      const file = matched.files.get(modality);
      if (file) {
        tupleImages.push({
          file,
          modality
        });
        names.push(file.name);
      }
    }

    // Only create tuple if at least one image exists
    if (tupleImages.length > 0) {
      const tupleName = findCommonSubstring(names) || matched.key;
      tuples.push({
        name: tupleName,
        imageData: tupleImages
      });
    }
  }

  // Log info about partial tuples
  const partialCount = tuples.filter(t => t.imageData.length < modalities.length).length;
  if (partialCount > 0) {
    console.log(`${partialCount} tuples are missing some modalities`);
  }

  isMultiTupleMode = tuples.length > 1;
  currentTupleIndex = 0;

  // Calculate carousel thumb size based on number of modalities
  updateCarouselThumbSize();

  await loadTuple(0);
}

async function processSubdirectoriesAsModalitiesLegacy(filesByDir) {
  // Sort modalities alphabetically
  modalities = Array.from(filesByDir.keys()).sort();
  modalityColors = modalities.map((_, i) => MODALITY_COLORS[i % MODALITY_COLORS.length]);

  // Legacy format has {name, file} objects - convert to file-like with name property
  const filesByModality = new Map();
  for (const modality of modalities) {
    const files = filesByDir.get(modality);
    // Wrap legacy format: {name, file} -> file with .name accessible
    filesByModality.set(modality, files.map(fd => ({
      ...fd.file,
      name: fd.name,
      _originalFile: fd.file
    })));
  }

  // Use trie-based matching to group files into tuples
  const matchedTuples = matchTuplesWithTrie(filesByModality, modalities);

  if (matchedTuples.length === 0) {
    alert('No images found in modalities');
    return;
  }

  // Build tuples from matched files
  tuples = [];
  for (const matched of matchedTuples) {
    const tupleImages = [];
    const names = [];

    // Add files in modality order
    for (const modality of modalities) {
      const fileData = matched.files.get(modality);
      if (fileData) {
        tupleImages.push({
          file: fileData._originalFile || fileData,
          modality
        });
        names.push(fileData.name);
      }
    }

    // Only create tuple if at least one image exists
    if (tupleImages.length > 0) {
      const tupleName = findCommonSubstring(names) || matched.key;
      tuples.push({
        name: tupleName,
        imageData: tupleImages
      });
    }
  }

  // Log info about partial tuples
  const partialCount = tuples.filter(t => t.imageData.length < modalities.length).length;
  if (partialCount > 0) {
    console.log(`${partialCount} tuples are missing some modalities`);
  }

  isMultiTupleMode = tuples.length > 1;
  currentTupleIndex = 0;

  updateCarouselThumbSize();

  await loadTuple(0);
}

async function processSubdirectoriesAsModalitiesModern(filesByDir) {
  // Sort modalities alphabetically
  modalities = Array.from(filesByDir.keys()).sort();
  modalityColors = modalities.map((_, i) => MODALITY_COLORS[i % MODALITY_COLORS.length]);

  // Modern format has {name, file} objects - convert to file-like with name property
  const filesByModality = new Map();
  for (const modality of modalities) {
    const files = filesByDir.get(modality);
    // Wrap modern format: {name, file} -> file with .name accessible
    filesByModality.set(modality, files.map(fd => ({
      ...fd.file,
      name: fd.name,
      _originalFile: fd.file
    })));
  }

  // Use trie-based matching to group files into tuples
  const matchedTuples = matchTuplesWithTrie(filesByModality, modalities);

  if (matchedTuples.length === 0) {
    alert('No images found in modalities');
    return;
  }

  // Build tuples from matched files
  tuples = [];
  for (const matched of matchedTuples) {
    const tupleImages = [];
    const names = [];

    // Add files in modality order
    for (const modality of modalities) {
      const fileData = matched.files.get(modality);
      if (fileData) {
        tupleImages.push({
          file: fileData._originalFile || fileData,
          modality
        });
        names.push(fileData.name);
      }
    }

    // Only create tuple if at least one image exists
    if (tupleImages.length > 0) {
      const tupleName = findCommonSubstring(names) || matched.key;
      tuples.push({
        name: tupleName,
        imageData: tupleImages
      });
    }
  }

  // Log info about partial tuples
  const partialCount = tuples.filter(t => t.imageData.length < modalities.length).length;
  if (partialCount > 0) {
    console.log(`${partialCount} tuples are missing some modalities`);
  }

  isMultiTupleMode = tuples.length > 1;
  currentTupleIndex = 0;

  updateCarouselThumbSize();

  await loadTuple(0);
}

function updateCarouselThumbSize() {
  // Calculate thumb size so all modalities fit in carousel width
  // Account for padding (6px each side) and gaps (2px between thumbs)
  const numModalities = modalities.length;
  const availableWidth = CAROUSEL_WIDTH - 12 - (numModalities - 1) * 2;
  CAROUSEL_THUMB_SIZE = Math.floor(availableWidth / numModalities);
  CAROUSEL_THUMB_SIZE = Math.max(30, CAROUSEL_THUMB_SIZE);  // Minimum 30px, no maximum
}

// Find common substring among filenames (for tuple naming)
function findCommonSubstring(names) {
  if (names.length === 0) return '';
  if (names.length === 1) return names[0].replace(/\.[^.]+$/, '');  // Remove extension

  // Remove extensions
  const basenames = names.map(n => n.replace(/\.[^.]+$/, ''));

  // Find longest common substring
  let common = basenames[0];

  for (let i = 1; i < basenames.length; i++) {
    common = longestCommonSubstring(common, basenames[i]);
    if (!common) break;
  }

  // Clean up: remove trailing/leading underscores, dashes, spaces
  common = common.replace(/^[\s_-]+|[\s_-]+$/g, '');

  return common;
}

function longestCommonSubstring(s1, s2) {
  if (!s1 || !s2) return '';

  const len1 = s1.length;
  const len2 = s2.length;

  // Build matrix of common suffixes
  const dp = Array(len1 + 1).fill(null).map(() => Array(len2 + 1).fill(0));
  let maxLen = 0;
  let endPos = 0;

  for (let i = 1; i <= len1; i++) {
    for (let j = 1; j <= len2; j++) {
      if (s1[i-1] === s2[j-1]) {
        dp[i][j] = dp[i-1][j-1] + 1;
        if (dp[i][j] > maxLen) {
          maxLen = dp[i][j];
          endPos = i;
        }
      }
    }
  }

  return s1.substring(endPos - maxLen, endPos);
}

// Find difference in filenames (for modality naming when dropping files)
function findDifferingParts(names) {
  if (names.length < 2) return names;

  // Remove extensions
  const basenames = names.map(n => n.replace(/\.[^.]+$/, ''));

  // Find common prefix and suffix
  let prefix = basenames[0];
  let suffix = basenames[0];

  for (const name of basenames) {
    // Find common prefix
    let i = 0;
    while (i < prefix.length && i < name.length && prefix[i] === name[i]) i++;
    prefix = prefix.substring(0, i);

    // Find common suffix
    let j = 0;
    while (j < suffix.length && j < name.length &&
           suffix[suffix.length - 1 - j] === name[name.length - 1 - j]) j++;
    suffix = suffix.substring(suffix.length - j);
  }

  // Extract the differing parts
  return basenames.map(name => {
    let diff = name.substring(prefix.length, name.length - suffix.length);
    // Clean up
    diff = diff.replace(/^[\s_-]+|[\s_-]+$/g, '');
    return diff || name;
  });
}

async function readDirectory(dirEntry) {
  const allEntries = [];

  await new Promise((resolve, reject) => {
    const reader = dirEntry.createReader();

    function readBatch() {
      reader.readEntries((entries) => {
        if (entries.length === 0) {
          resolve();
          return;
        }
        for (const entry of entries) {
          if (entry.isFile) {
            const ext = entry.name.split('.').pop().toLowerCase();
            if (IMAGE_EXTENSIONS.includes(ext)) {
              allEntries.push(entry);
            }
          }
        }
        readBatch();
      }, (err) => {
        console.error('readEntries error:', err);
        reject(err);
      });
    }
    readBatch();
  });

  // Convert entries to files
  const allFiles = [];
  for (const entry of allEntries) {
    try {
      const file = await getFileFromEntry(entry);
      if (file) {
        allFiles.push({ name: entry.name, file });
      }
    } catch (err) {
      console.warn(`Skipping ${entry.name}:`, err);
    }
  }

  return allFiles;
}

function getFileFromEntry(entry) {
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error('Timeout reading file'));
    }, 5000);

    try {
      entry.file(
        (file) => {
          clearTimeout(timeout);
          resolve(file);
        },
        (err) => {
          clearTimeout(timeout);
          reject(err);
        }
      );
    } catch (err) {
      clearTimeout(timeout);
      reject(err);
    }
  });
}

function naturalSort(a, b) {
  return a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' });
}

// Strip file extension
function stripExtension(filename) {
  return filename.replace(/\.[^.]+$/, '');
}

// Longest Common Subsequence length for tie-breaking
// Uses O(n) space with two-row optimization
function lcsLength(a, b) {
  const m = a.length, n = b.length;
  let prev = new Array(n + 1).fill(0);
  let curr = new Array(n + 1).fill(0);

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (a[i-1] === b[j-1]) {
        curr[j] = prev[j-1] + 1;
      } else {
        curr[j] = Math.max(prev[j], curr[j-1]);
      }
    }
    [prev, curr] = [curr, prev];
  }

  return prev[n];
}

// Trie-based tuple matching with LCP scoring and LCS tie-breaking
//
// Algorithm:
// 1. Pick reference modality (one with most files)
// 2. Build trie from reference filenames - each node tracks which files pass through
// 3. For each file in other modalities:
//    - Walk trie to find longest matching prefix (LCP)
//    - Collect candidate reference files at deepest matched node
//    - Use LCS (longest common subsequence) as tie-breaker
// 4. Group files by their matched reference file
//
// Complexity: O(N * L) for trie ops, O(ties * L¬≤) for LCS tie-breaking
// where N = total files, L = max filename length
function matchTuplesWithTrie(filesByModality, modalityNames) {
  if (modalityNames.length < 2) {
    // Single modality - return each file as its own tuple
    if (modalityNames.length === 1) {
      const mod = modalityNames[0];
      const files = filesByModality.get(mod) || [];
      return files.map(f => ({
        key: stripExtension(f.name),
        files: new Map([[mod, f]])
      }));
    }
    return [];
  }

  // Pick reference modality (most files) - ensures best coverage
  let refMod = modalityNames[0];
  let maxCount = (filesByModality.get(refMod) || []).length;
  for (const mod of modalityNames) {
    const count = (filesByModality.get(mod) || []).length;
    if (count > maxCount) {
      maxCount = count;
      refMod = mod;
    }
  }

  const refFiles = filesByModality.get(refMod) || [];
  if (refFiles.length === 0) return [];

  // Build trie from reference filenames
  // Each node has: children (Map), indices (array of refFile indices that pass through)
  const trie = { children: new Map(), indices: [] };

  for (let i = 0; i < refFiles.length; i++) {
    const key = stripExtension(refFiles[i].name);
    let node = trie;
    // Add index at root level too (for files with no common prefix)
    node.indices.push(i);

    for (const char of key) {
      if (!node.children.has(char)) {
        node.children.set(char, { children: new Map(), indices: [] });
      }
      node = node.children.get(char);
      node.indices.push(i);
    }
  }

  // Create tuple map: refIndex -> Map(modality -> file)
  const tupleMap = new Map();
  for (let i = 0; i < refFiles.length; i++) {
    tupleMap.set(i, new Map([[refMod, refFiles[i]]]));
  }

  // Track which reference files got matched (for orphan detection)
  const matchedToRef = new Map(); // non-ref file -> refIndex

  // Match files from other modalities using trie lookup
  for (const mod of modalityNames) {
    if (mod === refMod) continue;

    const files = filesByModality.get(mod) || [];
    for (const file of files) {
      const query = stripExtension(file.name);

      // Walk trie to find deepest matching node (longest common prefix)
      let node = trie;
      let bestNode = trie;  // Track deepest node with indices

      for (const char of query) {
        if (!node.children.has(char)) break;
        node = node.children.get(char);
        if (node.indices.length > 0) {
          bestNode = node;
        }
      }

      const candidates = bestNode.indices;
      if (candidates.length === 0) {
        // No match found - skip (shouldn't happen with valid trie)
        continue;
      }

      // Find best match among candidates
      let bestIdx = candidates[0];

      if (candidates.length > 1) {
        // Tie-breaker: use LCS (longest common subsequence)
        // Files with more characters in common (even non-contiguous) score higher
        let bestScore = -1;
        for (const idx of candidates) {
          const refName = stripExtension(refFiles[idx].name);
          const score = lcsLength(query, refName);
          if (score > bestScore) {
            bestScore = score;
            bestIdx = idx;
          }
        }
      }

      // Add to tuple
      tupleMap.get(bestIdx).set(mod, file);
    }
  }

  // Convert to array format expected by the caller
  const result = [];
  for (const [idx, filesMap] of tupleMap) {
    result.push({
      key: stripExtension(refFiles[idx].name),
      files: filesMap
    });
  }

  // Sort by key for consistent ordering
  result.sort((a, b) =>
    a.key.localeCompare(b.key, undefined, { numeric: true, sensitivity: 'base' })
  );

  return result;
}

async function readDirectoryModern(dirHandle) {
  const files = [];
  for await (const entry of dirHandle.values()) {
    if (entry.kind === 'file') {
      const ext = entry.name.split('.').pop().toLowerCase();
      if (IMAGE_EXTENSIONS.includes(ext)) {
        try {
          const file = await entry.getFile();
          files.push({ name: entry.name, file });
        } catch (err) {
          console.warn(`Skipping ${entry.name}:`, err);
        }
      }
    }
  }
  return files;
}

// Winner voting functions

/**
 * Toggle winner for current tuple/modality
 */
function toggleWinner(tupleIndex, modalityIndex) {
  if (!votingEnabled) return;

  const currentWinner = winners.get(tupleIndex);

  if (currentWinner === modalityIndex) {
    // Already winner - clear it
    winners.delete(tupleIndex);
  } else {
    // Set as winner
    winners.set(tupleIndex, modalityIndex);
  }

  // Update UI
  updateCarouselWinners();
  updateModalitySelector();

  // Save to file
  saveResults();
}

/**
 * Update winner indicators in carousel
 */
function updateCarouselWinners() {
  if (!isMultiTupleMode || !votingEnabled) return;

  const indicators = carousel.querySelectorAll('.winner-indicator');
  indicators.forEach((indicator) => {
    const tupleIdx = parseInt(indicator.dataset.tupleIndex);
    const modIdx = parseInt(indicator.dataset.modalityIndex);

    const winnerModalityIdx = winners.get(tupleIdx);
    if (winnerModalityIdx === modIdx) {
      indicator.classList.add('winner');
    } else {
      indicator.classList.remove('winner');
    }
  });
}

/**
 * Save winners to results.txt using File System Access API
 */
async function saveResults() {
  if (!rootDirHandle || !votingEnabled) return;

  try {
    // If no winners, delete the file
    if (winners.size === 0) {
      try {
        await rootDirHandle.removeEntry('results.txt');
      } catch {
        // File doesn't exist - that's OK
      }
      return;
    }

    // Build file content
    const lines = [
      '# ImageCompare Results',
      `# Generated: ${new Date().toISOString()}`,
      `# Modalities: ${modalities.join(', ')}`,
      '#',
      '# Format: tuple_key = winner_modality',
      '# Delete a line to remove the vote, edit modality name to change vote',
      ''
    ];

    // Sort winners by tuple index for consistent output
    const sortedWinners = Array.from(winners.entries()).sort((a, b) => a[0] - b[0]);

    for (const [tupleIndex, modalityIndex] of sortedWinners) {
      const tuple = tuples[tupleIndex];
      const modalityName = modalities[modalityIndex];
      if (tuple && modalityName) {
        lines.push(`${tuple.name} = ${modalityName}`);
      }
    }

    const content = lines.join('\n') + '\n';

    // Write to file
    const fileHandle = await rootDirHandle.getFileHandle('results.txt', { create: true });
    const writable = await fileHandle.createWritable();
    await writable.write(content);
    await writable.close();

    console.log('Saved results.txt');
  } catch (err) {
    console.warn('Failed to save results.txt:', err);
  }
}

/**
 * Load winners from results.txt
 */
async function loadResults() {
  if (!rootDirHandle || !votingEnabled) return;

  try {
    const fileHandle = await rootDirHandle.getFileHandle('results.txt');
    const file = await fileHandle.getFile();
    const content = await file.text();

    // Parse file
    const savedWinners = new Map();  // tupleName -> modalityName
    const lines = content.split('\n');

    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith('#')) continue;

      const eqIndex = trimmed.indexOf('=');
      if (eqIndex === -1) continue;

      const tupleKey = trimmed.substring(0, eqIndex).trim();
      const modalityName = trimmed.substring(eqIndex + 1).trim();

      if (tupleKey && modalityName) {
        savedWinners.set(tupleKey, modalityName);
      }
    }

    // Map saved winners to indices
    winners = new Map();
    for (let tupleIndex = 0; tupleIndex < tuples.length; tupleIndex++) {
      const tuple = tuples[tupleIndex];
      const winnerName = savedWinners.get(tuple.name);
      if (winnerName) {
        const modalityIndex = modalities.indexOf(winnerName);
        if (modalityIndex !== -1) {
          winners.set(tupleIndex, modalityIndex);
        }
      }
    }

    console.log(`Loaded ${winners.size} winners from results.txt`);

    // Update UI
    updateCarouselWinners();
    updateModalitySelector();
  } catch (err) {
    // File doesn't exist or can't be read - that's OK
    console.log('No results.txt found or failed to load');
  }
}

// Generate thumbnail data URL from file using createImageBitmap for non-blocking decode
async function generateThumbnail(file, size) {
  const ext = file.name.split('.').pop().toLowerCase();

  // Handle PPMX files specially - load via loadPpmx then scale
  if (ext === 'ppmx') {
    try {
      const { img, width, height, url } = await loadPpmx(file);
      const scale = Math.min(size / width, size / height);
      const w = Math.round(width * scale);
      const h = Math.round(height * scale);

      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, w, h);
      URL.revokeObjectURL(url);
      return canvas.toDataURL('image/jpeg', 0.7);
    } catch (err) {
      console.warn('Failed to generate PPMX thumbnail:', err);
      throw err;
    }
  }

  try {
    // createImageBitmap decodes off the main thread
    const bitmap = await createImageBitmap(file);

    // Calculate scaled size maintaining aspect ratio
    const scale = Math.min(size / bitmap.width, size / bitmap.height);
    const w = Math.round(bitmap.width * scale);
    const h = Math.round(bitmap.height * scale);

    // Use OffscreenCanvas if available for fully off-thread rendering
    let canvas, ctx;
    if (typeof OffscreenCanvas !== 'undefined') {
      canvas = new OffscreenCanvas(w, h);
      ctx = canvas.getContext('2d');
      ctx.drawImage(bitmap, 0, 0, w, h);
      const blob = await canvas.convertToBlob({ type: 'image/jpeg', quality: 0.7 });
      bitmap.close();
      return URL.createObjectURL(blob);
    } else {
      // Fallback for browsers without OffscreenCanvas
      canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      ctx = canvas.getContext('2d');
      ctx.drawImage(bitmap, 0, 0, w, h);
      bitmap.close();
      return canvas.toDataURL('image/jpeg', 0.7);
    }
  } catch (err) {
    // Fallback to traditional method
    return new Promise((resolve, reject) => {
      const img = new Image();
      const url = URL.createObjectURL(file);

      img.onload = () => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const scale = Math.min(size / img.width, size / img.height);
        const w = Math.round(img.width * scale);
        const h = Math.round(img.height * scale);
        canvas.width = w;
        canvas.height = h;
        ctx.drawImage(img, 0, 0, w, h);
        const dataUrl = canvas.toDataURL('image/jpeg', 0.7);
        URL.revokeObjectURL(url);
        resolve(dataUrl);
      };

      img.onerror = () => {
        URL.revokeObjectURL(url);
        reject(new Error('Failed to load image for thumbnail'));
      };

      img.src = url;
    });
  }
}

// Preload a tuple's full images (indexed by modality position)
async function preloadTupleImages(tupleIdx) {
  if (tupleIdx < 0 || tupleIdx >= tuples.length) return null;
  if (preloadedTuples.has(tupleIdx)) return preloadedTuples.get(tupleIdx);

  const tuple = tuples[tupleIdx];

  try {
    // Build a map of modality -> imageData for this tuple
    const imageDataByModality = new Map();
    for (const imgData of tuple.imageData) {
      imageDataByModality.set(imgData.modality, imgData);
    }

    // Load images indexed by modality position (undefined for missing)
    const loadedImages = await Promise.all(
      modalities.map(async (modalityName) => {
        const imgData = imageDataByModality.get(modalityName);
        if (!imgData) {
          return undefined;  // Missing modality
        }
        const loaded = await loadImage(imgData.file);
        loaded.modality = modalityName;
        return loaded;
      })
    );

    preloadedTuples.set(tupleIdx, loadedImages);
    return loadedImages;
  } catch (err) {
    console.warn(`Failed to preload tuple ${tupleIdx}:`, err);
    return null;
  }
}

// Preload tuples around current position
function triggerPreload(centerIdx) {
  // Preload ahead and behind
  for (let offset = 1; offset <= PRELOAD_AHEAD; offset++) {
    const ahead = centerIdx + offset;
    const behind = centerIdx - offset;

    if (ahead < tuples.length && !preloadedTuples.has(ahead)) {
      preloadTupleImages(ahead);
    }
    if (behind >= 0 && !preloadedTuples.has(behind)) {
      preloadTupleImages(behind);
    }
  }

  // Clean up old preloaded tuples that are too far away
  for (const [idx, imgs] of preloadedTuples.entries()) {
    if (Math.abs(idx - centerIdx) > PRELOAD_AHEAD + 2) {
      // Revoke URLs (skip undefined entries)
      if (imgs) {
        imgs.forEach(img => { if (img && img.url) URL.revokeObjectURL(img.url); });
      }
      preloadedTuples.delete(idx);
    }
  }
}

async function loadTuple(index) {
  if (index < 0 || index >= tuples.length) return;

  // Preserve current modality index when switching tuples
  const preservedModalityIndex = currentModalityIndex;

  currentTupleIndex = index;
  const tuple = tuples[index];

  try {
    // Build a map of modality -> imageData for this tuple
    const imageDataByModality = new Map();
    for (const imgData of tuple.imageData) {
      imageDataByModality.set(imgData.modality, imgData);
    }

    // Load images into an array indexed by modality position
    // Missing modalities will be undefined
    const loadedImages = await Promise.all(
      modalities.map(async (modalityName) => {
        const imgData = imageDataByModality.get(modalityName);
        if (!imgData) {
          return undefined;  // Missing modality
        }
        const loaded = await loadImage(imgData.file);
        loaded.modality = modalityName;
        return loaded;
      })
    );

    // Check aspect ratios for available images
    const availableImages = loadedImages.filter(img => img !== undefined);
    if (availableImages.length > 0) {
      const aspects = availableImages.map(img => img.width / img.height);
      const baseAspect = aspects[0];
      const tolerance = 0.01;

      const mismatch = aspects.find((a, i) =>
        i > 0 && Math.abs(a - baseAspect) / Math.max(a, baseAspect) > tolerance
      );

      if (mismatch !== undefined) {
        console.warn(`Aspect ratio mismatch in tuple ${index + 1}`);
        const details = availableImages.map(img =>
          `${img.modality}: ${img.width}√ó${img.height}`
        ).join(', ');
        console.warn(details);
      }
    }

    activateViewer(loadedImages, tuple.name, preservedModalityIndex);

    // Trigger preloading of nearby tuples
    triggerPreload(index);
  } catch (err) {
    alert('Error loading tuple: ' + err.message);
  }
}

function handleFiles(files) {
  const imageFiles = Array.from(files).filter(f => {
    const ext = f.name.split('.').pop().toLowerCase();
    return f.type.startsWith('image/') || IMAGE_EXTENSIONS.includes(ext);
  });

  if (imageFiles.length < 2) {
    alert('Please drop at least 2 images to form a tuple');
    return;
  }

  handleFilesAsTuple(imageFiles);
}

async function handleFilesAsTuple(imageFiles) {
  // Sort files
  imageFiles.sort((a, b) => naturalSort({ name: a.name }, { name: b.name }));

  // Determine modalities from differing parts of filenames
  const names = imageFiles.map(f => f.name);
  modalities = findDifferingParts(names);
  modalityColors = modalities.map((_, i) => MODALITY_COLORS[i % MODALITY_COLORS.length]);

  // File mode doesn't support voting (no directory to save to)
  rootDirHandle = null;
  votingEnabled = false;
  winners = new Map();

  // Ensure unique modality names
  const seen = new Map();
  modalities = modalities.map((m, i) => {
    if (seen.has(m)) {
      const count = seen.get(m) + 1;
      seen.set(m, count);
      return `${m} (${count})`;
    }
    seen.set(m, 1);
    return m;
  });

  try {
    const loadedImages = await Promise.all(
      imageFiles.map(async (file, i) => {
        const loaded = await loadImage(file);
        loaded.modality = modalities[i];
        return loaded;
      })
    );

    // Check aspect ratios
    checkAndLoadTuple(loadedImages);
  } catch (err) {
    alert('Error loading images: ' + err.message);
  }
}

// Load a .ppmx file (custom float32 format) and convert to grayscale image
async function loadPpmx(file) {
  const buffer = await file.arrayBuffer();
  const bytes = new Uint8Array(buffer);

  // Find line breaks to parse header
  let pos = 0;
  const lines = [];
  for (let i = 0; i < 3; i++) {
    let lineEnd = pos;
    while (lineEnd < bytes.length && bytes[lineEnd] !== 10) lineEnd++;
    const line = new TextDecoder().decode(bytes.slice(pos, lineEnd));
    lines.push(line.trim());
    pos = lineEnd + 1;
  }

  const [header, dims, flags] = lines;

  // Validate header
  if (header !== 'P7') {
    throw new Error(`Unexpected PPMX header: "${header}", expected "P7"`);
  }

  // Parse dimensions
  const [w, h] = dims.split(/\s+/).map(Number);
  if (!w || !h) {
    throw new Error(`Invalid PPMX dimensions: "${dims}"`);
  }

  // Validate flags (currently only "00000000000" is known)
  const KNOWN_FLAGS = new Set(['00000000000']);
  if (!KNOWN_FLAGS.has(flags)) {
    console.warn(`Unknown PPMX flags: "${flags}". Known flags: ${[...KNOWN_FLAGS].join(', ')}`);
  }

  // Read float32 data
  const dataBuffer = buffer.slice(pos);
  const floatData = new Float32Array(dataBuffer);

  if (floatData.length !== w * h) {
    throw new Error(`PPMX data size mismatch: expected ${w * h}, got ${floatData.length}`);
  }

  // Find min/max for normalization
  let min = Infinity, max = -Infinity;
  for (let i = 0; i < floatData.length; i++) {
    const v = floatData[i];
    if (isFinite(v)) {
      if (v < min) min = v;
      if (v > max) max = v;
    }
  }

  // Create grayscale image
  const canvas = document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;
  const ctx = canvas.getContext('2d');
  const imageData = ctx.createImageData(w, h);
  const pixels = imageData.data;

  const range = max - min || 1;
  for (let i = 0; i < floatData.length; i++) {
    const v = floatData[i];
    const normalized = isFinite(v) ? (v - min) / range : 0;
    const gray = Math.round(normalized * 255);
    const pi = i * 4;
    pixels[pi] = gray;     // R
    pixels[pi + 1] = gray; // G
    pixels[pi + 2] = gray; // B
    pixels[pi + 3] = 255;  // A
  }

  ctx.putImageData(imageData, 0, 0);

  // Convert canvas to blob URL for consistent handling
  return new Promise((resolve, reject) => {
    canvas.toBlob((blob) => {
      if (!blob) {
        reject(new Error('Failed to create blob from PPMX'));
        return;
      }
      const url = URL.createObjectURL(blob);
      const img = new Image();
      img.onload = () => {
        resolve({ img, name: file.name, width: w, height: h, url });
      };
      img.onerror = () => {
        URL.revokeObjectURL(url);
        reject(new Error(`Failed to load converted PPMX ${file.name}`));
      };
      img.src = url;
    }, 'image/png');
  });
}

function loadImage(file) {
  return new Promise(async (resolve, reject) => {
    const ext = file.name.split('.').pop().toLowerCase();
    if (!file.type.startsWith('image/') && !IMAGE_EXTENSIONS.includes(ext)) {
      reject(new Error(`${file.name} is not an image`));
      return;
    }

    // Handle PPMX files specially
    if (ext === 'ppmx') {
      try {
        const result = await loadPpmx(file);
        resolve(result);
      } catch (err) {
        reject(err);
      }
      return;
    }

    const img = new Image();
    const url = URL.createObjectURL(file);
    img.onload = () => {
      resolve({ img, name: file.name, width: img.width, height: img.height, url });
    };
    img.onerror = () => {
      URL.revokeObjectURL(url);
      reject(new Error(`Failed to load ${file.name}`));
    };
    img.src = url;
  });
}

function checkAndLoadTuple(loadedImages) {
  const aspects = loadedImages.map(img => img.width / img.height);
  const baseAspect = aspects[0];
  const tolerance = 0.01;

  const mismatchIndex = aspects.findIndex((a, i) =>
    i > 0 && Math.abs(a - baseAspect) / Math.max(a, baseAspect) > tolerance
  );

  if (mismatchIndex !== -1) {
    pendingImages = loadedImages;
    const details = loadedImages.map(img =>
      `<strong>${img.modality}</strong>: ${img.width}√ó${img.height} (${(img.width/img.height).toFixed(4)})`
    ).join('<br>');
    errorText.innerHTML = details;
    errorModal.classList.add('active');
    return;
  }

  // Find common name for tuple
  const tupleName = findCommonSubstring(loadedImages.map(img => img.name)) || 'Untitled';

  isMultiTupleMode = false;
  tuples = [{ name: tupleName, images: loadedImages }];
  currentTupleIndex = 0;

  activateViewer(loadedImages, tupleName);
}

function cancelLoad() {
  errorModal.classList.remove('active');
  pendingImages = null;
}

function continueLoad() {
  errorModal.classList.remove('active');
  if (pendingImages) {
    const tupleName = findCommonSubstring(pendingImages.map(img => img.name)) || 'Untitled';
    isMultiTupleMode = false;
    tuples = [{ name: tupleName, images: pendingImages }];
    currentTupleIndex = 0;
    activateViewer(pendingImages, tupleName);
    pendingImages = null;
  }
}

function activateViewer(loadedImages, tupleName, preserveModalityIndex = -1) {
  // Don't revoke URLs for preloaded images
  // Only revoke if they're not in preloaded cache
  for (const img of images) {
    if (!img) continue;
    let isPreloaded = false;
    for (const [_, preloaded] of preloadedTuples.entries()) {
      if (preloaded && preloaded.includes(img)) {
        isPreloaded = true;
        break;
      }
    }
    if (!isPreloaded && img.url) {
      URL.revokeObjectURL(img.url);
    }
  }

  images = loadedImages;

  // Preserve modality index if valid, otherwise find first available
  if (preserveModalityIndex >= 0 && preserveModalityIndex < modalities.length) {
    currentModalityIndex = preserveModalityIndex;
    previousModalityIndex = preserveModalityIndex;
  } else {
    // Find first available modality
    const firstAvailable = images.findIndex(img => img !== undefined);
    currentModalityIndex = firstAvailable >= 0 ? firstAvailable : 0;
    previousModalityIndex = currentModalityIndex;
  }

  zoom = 1;
  panX = panY = 0;
  isReset = false;

  dropzone.classList.add('hidden');
  viewer.classList.add('active');
  info.classList.remove('hidden');

  // Build modality selector buttons
  buildModalitySelector();

  // Compute and set fixed height for info bar based on all filenames
  computeInfoBarHeight(loadedImages, tupleName);

  // Build or update carousel (only in multi-tuple/dir mode)
  if (isMultiTupleMode && carousel.children.length === 0) {
    buildCarousel();
  } else {
    updateCarouselSelection();
  }

  render();
}

// Compute the max height needed for the info bar across all modalities in the tuple
function computeInfoBarHeight(loadedImages, tupleName) {
  // Reset to auto height first so we can measure
  info.style.height = 'auto';

  let maxHeight = 0;
  const originalNameText = statusName.textContent;
  const originalInfoText = statusInfo.textContent;

  // Measure height for each filename (skip undefined/missing)
  for (const img of loadedImages) {
    if (!img) continue;  // Skip missing modalities
    let nameText = `${img.name} (${img.width}√ó${img.height})`;
    if (isMultiTupleMode) {
      nameText = `[${currentTupleIndex + 1}/${tuples.length}] ` + nameText;
    }
    statusName.textContent = nameText;
    statusInfo.textContent = 'Zoom: 1.0√ó';

    // Force layout recalculation
    const height = info.offsetHeight;
    if (height > maxHeight) {
      maxHeight = height;
    }
  }

  // Also measure "not available" text
  let notAvailText = `Modality: not available`;
  if (isMultiTupleMode) {
    notAvailText = `[${currentTupleIndex + 1}/${tuples.length}] ` + notAvailText;
  }
  statusName.textContent = notAvailText;
  statusInfo.textContent = 'Zoom: 1.0√ó';
  const notAvailHeight = info.offsetHeight;
  if (notAvailHeight > maxHeight) {
    maxHeight = notAvailHeight;
  }

  // Restore original text
  statusName.textContent = originalNameText;
  statusInfo.textContent = originalInfoText;

  // Set fixed height
  info.style.height = maxHeight + 'px';
}

// Recompute info bar height on window resize
let resizeTimeout = null;
window.addEventListener('resize', () => {
  if (modalities.length === 0) return;

  // Debounce resize events
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    const tupleName = isMultiTupleMode ? tuples[currentTupleIndex].name : '';
    computeInfoBarHeight(images, tupleName);
  }, 100);
});

function buildModalitySelector() {
  modalitySelector.innerHTML = '';

  // Build buttons for all modalities (index = display position)
  modalities.forEach((modalityName, idx) => {
    const btn = document.createElement('button');
    btn.className = 'modality-btn';
    btn.textContent = `${idx + 1}: ${modalityName}`;
    btn.style.background = modalityColors[idx];
    btn.dataset.index = idx;

    // Mark as unavailable if missing
    const hasImage = images[idx] !== undefined;
    if (!hasImage) {
      btn.classList.add('unavailable');
    }

    btn.addEventListener('click', () => {
      if (currentModalityIndex !== idx) {
        previousModalityIndex = currentModalityIndex;
        currentModalityIndex = idx;
        render();
      }
    });

    modalitySelector.appendChild(btn);
  });

  updateModalitySelector();
}

// Move current modality left or right in the order
function moveCurrentModality(direction) {
  if (modalities.length < 2) return;

  const currentPos = currentModalityIndex;
  const newPos = currentPos + direction;

  // Check bounds
  if (newPos < 0 || newPos >= modalities.length) return;

  // Swap in images array
  const tempImg = images[currentPos];
  images[currentPos] = images[newPos];
  images[newPos] = tempImg;

  // Swap in modalityColors array
  const tempColor = modalityColors[currentPos];
  modalityColors[currentPos] = modalityColors[newPos];
  modalityColors[newPos] = tempColor;

  // Swap in modalities array
  const tempMod = modalities[currentPos];
  modalities[currentPos] = modalities[newPos];
  modalities[newPos] = tempMod;

  // Note: We do NOT swap in tuple.imageData because it's a sparse array
  // with objects that have their own 'modality' field. The carousel and
  // loading code look up images by modality name, not by array index.

  // Update winners to reflect swapped indices
  if (votingEnabled) {
    const newWinners = new Map();
    for (const [tupleIndex, winnerIdx] of winners) {
      if (winnerIdx === currentPos) {
        newWinners.set(tupleIndex, newPos);
      } else if (winnerIdx === newPos) {
        newWinners.set(tupleIndex, currentPos);
      } else {
        newWinners.set(tupleIndex, winnerIdx);
      }
    }
    winners = newWinners;
    // Save updated winners
    saveResults();
  }

  // Update currentModalityIndex to follow the moved modality
  currentModalityIndex = newPos;

  // Clear preloaded tuples since order changed
  for (const [_, imgs] of preloadedTuples.entries()) {
    if (imgs) imgs.forEach(img => { if (img && img.url) URL.revokeObjectURL(img.url); });
  }
  preloadedTuples.clear();

  // Rebuild UI
  buildModalitySelector();
  if (isMultiTupleMode) {
    rebuildCarouselThumbnails();
  }
  render();
}

function updateModalitySelector() {
  // Calculate win counts per modality
  const winCounts = new Array(modalities.length).fill(0);
  if (votingEnabled) {
    for (const [_, modalityIdx] of winners) {
      if (modalityIdx >= 0 && modalityIdx < winCounts.length) {
        winCounts[modalityIdx]++;
      }
    }
  }

  const buttons = modalitySelector.querySelectorAll('.modality-btn');
  buttons.forEach((btn) => {
    const idx = parseInt(btn.dataset.index);
    if (idx === currentModalityIndex) {
      btn.classList.add('active');
      btn.classList.remove('inactive');
    } else {
      btn.classList.remove('active');
      btn.classList.add('inactive');
    }

    // Update button text with win count if voting enabled and has wins
    const modalityName = modalities[idx];
    if (votingEnabled && winCounts[idx] > 0) {
      btn.textContent = `${idx + 1}: ${modalityName} (${winCounts[idx]})`;
    } else {
      btn.textContent = `${idx + 1}: ${modalityName}`;
    }
  });

  // Update reorder button states
  reorderLeftBtn.disabled = currentModalityIndex <= 0;
  reorderRightBtn.disabled = currentModalityIndex >= modalities.length - 1;
}


// Carousel functions
async function buildCarousel() {
  carousel.innerHTML = '';
  carousel.style.width = CAROUSEL_WIDTH + 'px';

  if (!isMultiTupleMode || tuples.length <= 1) {
    carousel.classList.remove('active');
    carouselResize.classList.remove('active');
    return;
  }

  carousel.classList.add('active');
  carouselResize.classList.add('active');
  carouselResize.style.left = (CAROUSEL_WIDTH - 4) + 'px';

  // Count total actual images (not placeholders)
  let totalThumbs = 0;
  for (const tuple of tuples) {
    totalThumbs += tuple.imageData.length;
  }
  let loadedThumbs = 0;

  // Count how many are already cached
  let cachedCount = 0;
  for (const tuple of tuples) {
    for (const imgData of tuple.imageData) {
      if (thumbnailCache.has(imgData.file)) cachedCount++;
    }
  }

  // Only show progress bar if we need to generate thumbnails
  const needsGeneration = cachedCount < totalThumbs;
  if (needsGeneration) {
    progressContainer.classList.add('active');
    progressText.textContent = 'Generating thumbnails...';
    progressFill.style.width = '0%';
  }

  // Build all rows first (with placeholder thumbs for missing modalities)
  const thumbElements = [];  // Array of {thumb, file, tupleIdx, modIdx}

  // Helper to find image data for a specific modality in a tuple
  function findImageForModality(tuple, modalityName) {
    return tuple.imageData.find(img => img.modality === modalityName);
  }

  for (let tupleIdx = 0; tupleIdx < tuples.length; tupleIdx++) {
    const tuple = tuples[tupleIdx];
    const row = document.createElement('div');
    row.className = 'carousel-row';
    row.dataset.tupleIndex = tupleIdx;

    // Iterate over all modalities (not just tuple.imageData)
    for (let modIdx = 0; modIdx < modalities.length; modIdx++) {
      const modalityName = modalities[modIdx];
      const imgData = findImageForModality(tuple, modalityName);

      // Create container for thumbnail + winner indicator
      const container = document.createElement('div');
      container.className = 'carousel-thumb-container';
      container.style.width = CAROUSEL_THUMB_SIZE + 'px';
      container.style.height = CAROUSEL_THUMB_SIZE + 'px';

      if (imgData) {
        // Normal thumbnail
        const thumb = document.createElement('img');
        thumb.className = 'carousel-thumb';
        thumb.style.width = CAROUSEL_THUMB_SIZE + 'px';
        thumb.style.height = CAROUSEL_THUMB_SIZE + 'px';
        thumb.dataset.tupleIndex = tupleIdx;
        thumb.dataset.modalityIndex = modIdx;
        thumb.dataset.modality = modalityName;

        const file = imgData.file;

        // If cached, set immediately
        if (thumbnailCache.has(file)) {
          thumb.src = thumbnailCache.get(file);
          loadedThumbs++;
        } else {
          // Queue for sequential generation
          thumbElements.push({ thumb, file, tupleIdx, modIdx });
        }

        // Click handler
        thumb.addEventListener('click', (e) => {
          e.stopPropagation();
          const ti = parseInt(thumb.dataset.tupleIndex);
          const mi = parseInt(thumb.dataset.modalityIndex);
          goToTupleAndModality(ti, mi);
        });

        container.appendChild(thumb);
      } else {
        // Placeholder for missing modality
        const placeholder = document.createElement('div');
        placeholder.className = 'carousel-thumb placeholder';
        placeholder.style.width = CAROUSEL_THUMB_SIZE + 'px';
        placeholder.style.height = CAROUSEL_THUMB_SIZE + 'px';
        placeholder.dataset.tupleIndex = tupleIdx;
        placeholder.dataset.modalityIndex = modIdx;
        placeholder.dataset.modality = modalityName;
        placeholder.title = `${modalityName} not available`;

        // Click handler - navigate to tuple (will fallback to available modality)
        placeholder.addEventListener('click', (e) => {
          e.stopPropagation();
          const ti = parseInt(placeholder.dataset.tupleIndex);
          const mi = parseInt(placeholder.dataset.modalityIndex);
          goToTupleAndModality(ti, mi);
        });

        container.appendChild(placeholder);
      }

      // Add winner indicator if voting is enabled
      if (votingEnabled) {
        const indicator = document.createElement('div');
        indicator.className = 'winner-indicator';
        indicator.dataset.tupleIndex = tupleIdx;
        indicator.dataset.modalityIndex = modIdx;

        // Check if this is the winner
        if (winners.get(tupleIdx) === modIdx) {
          indicator.classList.add('winner');
        }

        indicator.addEventListener('click', (e) => {
          e.stopPropagation();
          toggleWinner(tupleIdx, modIdx);
        });

        container.appendChild(indicator);
      }

      row.appendChild(container);
    }

    // Click on row
    row.addEventListener('click', () => {
      const ti = parseInt(row.dataset.tupleIndex);
      if (ti !== currentTupleIndex) {
        loadTuple(ti);
      }
    });

    carousel.appendChild(row);
  }

  updateCarouselSelection();

  // Generate uncached thumbnails sequentially (top to bottom)
  // Yield after each thumbnail to keep UI responsive during zoom/pan
  async function generateThumbnailsSequentially() {
    for (const { thumb, file, tupleIdx, modIdx } of thumbElements) {
      // Yield before each thumbnail to allow UI updates
      await new Promise(resolve => setTimeout(resolve, 0));

      try {
        const dataUrl = await generateThumbnail(file, CAROUSEL_THUMB_SIZE * 2);
        thumbnailCache.set(file, dataUrl);
        thumb.src = dataUrl;
        loadedThumbs++;

        const progress = Math.round((loadedThumbs / totalThumbs) * 100);
        progressFill.style.width = progress + '%';
        progressText.textContent = `Generating thumbnails... ${loadedThumbs}/${totalThumbs}`;
      } catch (err) {
        console.warn(`Failed to generate thumbnail for tuple ${tupleIdx}, mod ${modIdx}:`, err);
        loadedThumbs++;
      }
    }

    // Done - hide progress bar
    progressContainer.classList.remove('active');
  }

  if (thumbElements.length > 0) {
    generateThumbnailsSequentially();
  } else {
    progressContainer.classList.remove('active');
  }
}

function rebuildCarouselThumbnails() {
  // Rebuild carousel after reordering
  if (!isMultiTupleMode) return;
  buildCarousel();
}

function updateCarouselSelection() {
  if (!isMultiTupleMode) return;

  // Get current modality name from modalities array
  const currentModality = modalities[currentModalityIndex];

  const rows = carousel.querySelectorAll('.carousel-row');
  rows.forEach((row, rowIdx) => {
    if (rowIdx === currentTupleIndex) {
      row.classList.add('current');
    } else {
      row.classList.remove('current');
    }

    // Find thumbs inside containers
    const containers = row.querySelectorAll('.carousel-thumb-container');
    containers.forEach((container) => {
      const thumb = container.querySelector('.carousel-thumb');
      if (!thumb) return;

      const thumbModality = thumb.dataset.modality;

      // Active means it's in the current tuple
      if (rowIdx === currentTupleIndex) {
        thumb.classList.add('active');
      } else {
        thumb.classList.remove('active');
      }

      // Selected means it's the current modality in current tuple
      if (rowIdx === currentTupleIndex && thumbModality === currentModality) {
        thumb.classList.add('selected');
      } else {
        thumb.classList.remove('selected');
      }
    });
  });

  scrollCarouselToCurrentTuple();
}

function scrollCarouselToCurrentTuple() {
  if (!isMultiTupleMode) return;

  const rows = carousel.querySelectorAll('.carousel-row');
  if (rows.length === 0 || currentTupleIndex >= rows.length) return;

  const currentRow = rows[currentTupleIndex];

  // Calculate where the row should be (centered)
  const carouselHeight = carousel.clientHeight;
  const rowHeight = currentRow.offsetHeight;
  const rowTop = currentRow.offsetTop;

  const targetScroll = rowTop - (carouselHeight / 2) + (rowHeight / 2);

  carousel.scrollTo({
    top: Math.max(0, targetScroll),
    behavior: 'smooth'
  });
}

async function goToTupleAndModality(tupleIdx, modalityIdx) {
  if (tupleIdx === currentTupleIndex) {
    // Same tuple, just switch modality
    if (modalityIdx !== currentModalityIndex) {
      previousModalityIndex = currentModalityIndex;
      currentModalityIndex = modalityIdx;
      render();
      updateCarouselSelection();
    }
  } else {
    // Different tuple - load it with the specified modality
    currentModalityIndex = modalityIdx;
    await loadTuple(tupleIdx);
  }
}

function render() {
  if (modalities.length === 0) return;

  // Update modality selector
  updateModalitySelector();

  // Update carousel selection
  if (isMultiTupleMode) {
    updateCarouselSelection();
  }

  const currentImage = images[currentModalityIndex];
  const modalityName = modalities[currentModalityIndex];

  // Check if current modality is missing
  if (!currentImage) {
    // Show "not available" placeholder
    const carouselOffset = isMultiTupleMode ? CAROUSEL_WIDTH : 0;

    // Update status (two-part layout)
    let nameText = `${modalityName}: not available`;
    if (isMultiTupleMode) {
      nameText = `[${currentTupleIndex + 1}/${tuples.length}] ` + nameText;
    }
    statusName.textContent = nameText;
    statusInfo.textContent = `Zoom: ${zoom.toFixed(1)}√ó`;

    // Draw placeholder on canvas
    requestAnimationFrame(() => {
      canvas.width = 400;
      canvas.height = 200;
      ctx.fillStyle = '#333';
      ctx.fillRect(0, 0, 400, 200);
      ctx.fillStyle = '#666';
      ctx.font = 'bold 48px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('‚úï', 200, 90);
      ctx.font = '16px sans-serif';
      ctx.fillStyle = '#888';
      ctx.fillText('Image not available', 200, 140);

      canvas.style.width = '400px';
      canvas.style.height = '200px';

      const centerOffsetX = carouselOffset / 2;
      canvas.style.transform = `translate(calc(-50% + ${centerOffsetX}px), -50%)`;

      // Hide thumbnail navigator
      thumbnail.classList.remove('active');
    });
    return;
  }

  const { img, name, width, height } = currentImage;

  // Update status (two-part layout)
  let nameText = `${name} (${width}√ó${height})`;
  if (isMultiTupleMode) {
    nameText = `[${currentTupleIndex + 1}/${tuples.length}] ` + nameText;
  }
  statusName.textContent = nameText;
  statusInfo.textContent = `Zoom: ${zoom.toFixed(1)}√ó`;

  // Use requestAnimationFrame to ensure layout is updated before measuring
  requestAnimationFrame(() => {
    // Fit to viewer (account for carousel width)
    const carouselOffset = isMultiTupleMode ? CAROUSEL_WIDTH : 0;
    const vw = viewer.clientWidth - carouselOffset;
    const vh = viewer.clientHeight;
    const baseScale = Math.min(vw / width, vh / height);
    const scale = baseScale * zoom;

    canvas.width = width;
    canvas.height = height;
    ctx.drawImage(img, 0, 0);

    const displayW = width * scale;
    const displayH = height * scale;

    canvas.style.width = displayW + 'px';
    canvas.style.height = displayH + 'px';

    // Offset canvas center by half carousel width when carousel is visible
    const centerOffsetX = carouselOffset / 2;
    canvas.style.transform = `translate(calc(-50% + ${panX + centerOffsetX}px), calc(-50% + ${panY}px))`;

    // Update thumbnail
    renderThumbnail(img, width, height, vw, vh, baseScale);
  });
}

function renderThumbnail(img, imgW, imgH, viewerW, viewerH, baseScale) {
  // Only show thumbnail when zoomed in
  if (zoom <= 1.05) {
    thumbnail.classList.remove('active');
    return;
  }
  thumbnail.classList.add('active');

  // Calculate thumbnail size
  const thumbScale = Math.min(THUMB_MAX_SIZE / imgW, THUMB_MAX_SIZE / imgH);
  const thumbW = Math.round(imgW * thumbScale);
  const thumbH = Math.round(imgH * thumbScale);

  thumbCanvas.width = thumbW;
  thumbCanvas.height = thumbH;
  thumbCtx.drawImage(img, 0, 0, thumbW, thumbH);

  // Calculate viewport rectangle
  const scale = baseScale * zoom;
  const visibleW = viewerW / scale;
  const visibleH = viewerH / scale;

  // Center of view in image coordinates (accounting for pan)
  const centerX = imgW / 2 - panX / scale;
  const centerY = imgH / 2 - panY / scale;

  // Viewport bounds in image coordinates
  const vpLeft = centerX - visibleW / 2;
  const vpTop = centerY - visibleH / 2;

  // Convert to thumbnail coordinates
  const vpX = vpLeft * thumbScale;
  const vpY = vpTop * thumbScale;
  const vpW = visibleW * thumbScale;
  const vpH = visibleH * thumbScale;

  // Position the viewport indicator
  thumbViewport.style.left = (4 + Math.max(0, vpX)) + 'px';
  thumbViewport.style.top = (4 + Math.max(0, vpY)) + 'px';
  thumbViewport.style.width = Math.min(vpW, thumbW - Math.max(0, vpX)) + 'px';
  thumbViewport.style.height = Math.min(vpH, thumbH - Math.max(0, vpY)) + 'px';
}

// Keyboard controls
document.addEventListener('keydown', (e) => {
  // Close help modal on Escape
  if (e.code === 'Escape' && helpModal.classList.contains('active')) {
    closeHelpModal();
    e.preventDefault();
    return;
  }

  if (modalities.length === 0) return;

  switch(e.code) {
    case 'Space':
      e.preventDefault();
      if (!spaceDown) {
        spaceDown = true;
        // Flip to previous modality
        const temp = currentModalityIndex;
        currentModalityIndex = previousModalityIndex;
        previousModalityIndex = temp;
        render();
      }
      break;
    case 'ArrowRight':
      e.preventDefault();
      if (currentModalityIndex < modalities.length - 1) {
        previousModalityIndex = currentModalityIndex;
        currentModalityIndex++;
        render();
      }
      break;
    case 'ArrowLeft':
      e.preventDefault();
      if (currentModalityIndex > 0) {
        previousModalityIndex = currentModalityIndex;
        currentModalityIndex--;
        render();
      }
      break;
    case 'BracketLeft':
      e.preventDefault();
      moveCurrentModality(-1);
      break;
    case 'BracketRight':
      e.preventDefault();
      moveCurrentModality(1);
      break;
    case 'ArrowUp':
      e.preventDefault();
      if (isMultiTupleMode && currentTupleIndex > 0) {
        // Throttle when holding key down
        const now = Date.now();
        if (isLoadingTuple || (e.repeat && now - lastKeyNavTime < KEY_NAV_THROTTLE)) break;
        lastKeyNavTime = now;
        isLoadingTuple = true;
        loadTuple(currentTupleIndex - 1).finally(() => { isLoadingTuple = false; });
      }
      break;
    case 'ArrowDown':
      e.preventDefault();
      if (isMultiTupleMode && currentTupleIndex < tuples.length - 1) {
        // Throttle when holding key down
        const now2 = Date.now();
        if (isLoadingTuple || (e.repeat && now2 - lastKeyNavTime < KEY_NAV_THROTTLE)) break;
        lastKeyNavTime = now2;
        isLoadingTuple = true;
        loadTuple(currentTupleIndex + 1).finally(() => { isLoadingTuple = false; });
      }
      break;
    case 'Digit1': case 'Digit2': case 'Digit3': case 'Digit4':
    case 'Digit5': case 'Digit6': case 'Digit7': case 'Digit8': case 'Digit9':
      e.preventDefault();
      const idx = parseInt(e.code.replace('Digit', '')) - 1;
      if (idx < modalities.length && idx !== currentModalityIndex) {
        previousModalityIndex = currentModalityIndex;
        currentModalityIndex = idx;
        render();
      }
      break;
    case 'Enter':
      e.preventDefault();
      if (votingEnabled && isMultiTupleMode) {
        toggleWinner(currentTupleIndex, currentModalityIndex);
      }
      break;
    case 'KeyR':
    case 'Escape':
      if (e.code === 'Escape' && errorModal.classList.contains('active')) {
        cancelLoad();
        break;
      }
      // If already reset, go back to dropzone
      if (isReset && zoom === 1 && panX === 0 && panY === 0) {
        images.forEach(img => { if (img && img.url) URL.revokeObjectURL(img.url); });
        images = [];
        tuples = [];
        modalities = [];
        modalityColors = [];
        isMultiTupleMode = false;
        currentModalityIndex = 0;
        previousModalityIndex = 0;
        currentTupleIndex = 0;
        isReset = false;
        // Reset winner state
        winners = new Map();
        votingEnabled = false;
        rootDirHandle = null;
        viewer.classList.remove('active');
        dropzone.classList.remove('hidden');
        info.classList.add('hidden');
        thumbnail.classList.remove('active');
        carousel.classList.remove('active');
        carouselResize.classList.remove('active');
        carousel.innerHTML = '';
        progressContainer.classList.remove('active');
        // thumbnailCache is a WeakMap - it auto-cleans when file references are gone
        // Clear preloaded tuples
        for (const [_, imgs] of preloadedTuples.entries()) {
          imgs.forEach(img => { if (img.url) URL.revokeObjectURL(img.url); });
        }
        preloadedTuples.clear();
        break;
      }
      zoom = 1;
      panX = panY = 0;
      isReset = true;
      render();
      break;
  }
});

// Mouse wheel zoom - zoom towards mouse position
viewer.addEventListener('wheel', (e) => {
  // Check if over carousel
  const carouselRect = carousel.getBoundingClientRect();
  if (isMultiTupleMode && e.clientX >= carouselRect.left && e.clientX <= carouselRect.right &&
      e.clientY >= carouselRect.top && e.clientY <= carouselRect.bottom) {
    return;  // Let carousel handle it
  }

  e.preventDefault();
  const delta = e.deltaY > 0 ? 0.97 : 1.03;
  const newZoom = Math.max(0.1, Math.min(50, zoom * delta));

  // Get mouse position relative to viewer center (accounting for carousel)
  const rect = viewer.getBoundingClientRect();
  const carouselOffset = isMultiTupleMode ? CAROUSEL_WIDTH : 0;
  const mouseX = e.clientX - rect.left - carouselOffset - (rect.width - carouselOffset) / 2;
  const mouseY = e.clientY - rect.top - rect.height / 2;

  // Adjust pan so the point under the mouse stays fixed
  const zoomRatio = newZoom / zoom;
  panX = mouseX - (mouseX - panX) * zoomRatio;
  panY = mouseY - (mouseY - panY) * zoomRatio;

  zoom = newZoom;
  isReset = false;
  render();
}, { passive: false });

// Pan with mouse drag
viewer.addEventListener('mousedown', (e) => {
  // Don't start drag if clicking on carousel
  if (e.target.closest('#carousel')) return;

  isDragging = true;
  dragStartX = e.clientX - panX;
  dragStartY = e.clientY - panY;
  viewer.classList.add('dragging');
});

document.addEventListener('mousemove', (e) => {
  if (!isDragging) return;
  panX = e.clientX - dragStartX;
  panY = e.clientY - dragStartY;
  isReset = false;
  render();
});

document.addEventListener('mouseup', () => {
  isDragging = false;
  viewer.classList.remove('dragging');
});

// Space bar release - flip back
document.addEventListener('keyup', (e) => {
  if (e.code === 'Space') {
    spaceDown = false;
    if (modalities.length > 0) {
      // Flip back
      const temp = currentModalityIndex;
      currentModalityIndex = previousModalityIndex;
      previousModalityIndex = temp;
      render();
    }
  }
});

// Handle resize - re-render canvas immediately
window.addEventListener('resize', () => {
  if (modalities.length > 0) render();
});

// Carousel mouse wheel scrolling
carousel.addEventListener('wheel', (e) => {
  e.preventDefault();
  e.stopPropagation();
  carousel.scrollTop += e.deltaY;
}, { passive: false });

// Carousel resize handle
let isResizingCarousel = false;
let resizeStartX = 0;
let resizeStartWidth = 0;
let resizeCenterRowFraction = 0;  // Where in the row (0-1) is the viewport center?

carouselResize.addEventListener('mousedown', (e) => {
  e.preventDefault();
  e.stopPropagation();
  isResizingCarousel = true;
  resizeStartX = e.clientX;
  resizeStartWidth = CAROUSEL_WIDTH;
  carouselResize.classList.add('dragging');
  carousel.classList.add('resizing');
  document.body.style.cursor = 'ew-resize';

  // Capture where the viewport center is relative to the current row
  const rows = carousel.querySelectorAll('.carousel-row');
  const currentRow = rows[currentTupleIndex];
  if (currentRow && currentRow.offsetHeight > 0) {
    const viewportCenter = carousel.scrollTop + carousel.clientHeight / 2;
    const rowTop = currentRow.offsetTop;
    // How far into the row is the viewport center? (as fraction of row height)
    resizeCenterRowFraction = (viewportCenter - rowTop) / currentRow.offsetHeight;
  }
});

document.addEventListener('mousemove', (e) => {
  if (!isResizingCarousel) return;

  const delta = e.clientX - resizeStartX;
  const newWidth = Math.max(100, Math.min(500, resizeStartWidth + delta));
  CAROUSEL_WIDTH = newWidth;
  carousel.style.width = CAROUSEL_WIDTH + 'px';
  carouselResize.style.left = (CAROUSEL_WIDTH - 4) + 'px';

  // Recalculate thumbnail size
  updateCarouselThumbSize();

  // Update thumbnail sizes in DOM
  const thumbs = carousel.querySelectorAll('.carousel-thumb');
  thumbs.forEach(thumb => {
    thumb.style.width = CAROUSEL_THUMB_SIZE + 'px';
    thumb.style.height = CAROUSEL_THUMB_SIZE + 'px';
  });

  // Restore scroll so the viewport center stays at the same position in the current row
  const rows = carousel.querySelectorAll('.carousel-row');
  const currentRow = rows[currentTupleIndex];
  if (currentRow) {
    const rowTop = currentRow.offsetTop;
    // The viewport center should be at rowTop + fraction * rowHeight
    const targetViewportCenter = rowTop + resizeCenterRowFraction * currentRow.offsetHeight;
    const newScrollTop = targetViewportCenter - carousel.clientHeight / 2;
    // Clamp to valid range
    const maxScroll = Math.max(0, carousel.scrollHeight - carousel.clientHeight);
    carousel.scrollTop = Math.max(0, Math.min(maxScroll, newScrollTop));
  }

  render();
});

document.addEventListener('mouseup', () => {
  if (isResizingCarousel) {
    isResizingCarousel = false;
    carouselResize.classList.remove('dragging');
    carousel.classList.remove('resizing');
    document.body.style.cursor = '';
  }
});
</script>
</body>
</html>
