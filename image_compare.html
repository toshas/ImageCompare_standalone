<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Image Compare</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üîç</text></svg>">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #1a1a1a;
  color: #fff;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  height: 100vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}
#dropzone {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 3px dashed #444;
  margin: 20px;
  border-radius: 12px;
  transition: border-color 0.2s, background 0.2s;
}
#dropzone.dragover {
  border-color: #0af;
  background: rgba(0, 170, 255, 0.1);
}
#dropzone.hidden { display: none; }
.drop-text {
  text-align: center;
  color: #888;
}
.drop-text h2 { font-size: 24px; margin-bottom: 10px; }
.drop-text p { font-size: 14px; }

#viewer {
  display: none;
  flex: 1;
  position: relative;
  overflow: hidden;
  cursor: grab;
}
#viewer.active { display: block; }
#viewer.dragging { cursor: grabbing; }

#canvas {
  position: absolute;
  top: 50%;
  left: 50%;
  transform-origin: center center;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}

/* Floating panel (minimap + tools) */
#floating-panel {
  position: absolute;
  top: 10px;
  right: 10px;
  background: rgba(0, 0, 0, 0.85);
  border: 1px solid #444;
  border-radius: 6px;
  z-index: 20;
  min-width: 160px;
  user-select: none;
  display: none;
}
#floating-panel.active { display: block; }
#fp-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1px 6px;
  cursor: move;
  background: rgba(255, 255, 255, 0.18);
  border-radius: 6px 6px 0 0;
  font-size: 11px;
  font-weight: 600;
  color: #ccc;
  letter-spacing: 0.3px;
}
#fp-collapse-btn {
  cursor: pointer;
  font-size: 18px;
  padding: 0 2px;
  line-height: 1;
  color: #fff;
}
#fp-body { padding: 4px; }
#floating-panel.collapsed #fp-body { display: none; }
#floating-panel.collapsed { min-width: auto; }
#floating-panel.collapsed #fp-header { border-radius: 6px; }
#fp-minimap {
  position: relative;
  margin-bottom: 4px;
}
#thumb-canvas {
  display: block;
  margin: 0 auto;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}
#thumb-viewport {
  position: absolute;
  border: 2px solid #f0f;
  pointer-events: none;
  box-sizing: border-box;
}
#fp-actions {
  display: flex;
  gap: 4px;
  justify-content: flex-end;
}
#fp-actions.hidden { display: none; }

#info {
  background: #2a2a2a;
  padding: 6px 12px;
  display: flex;
  align-items: center;
  font-size: 13px;
  flex-shrink: 0;
  min-height: 36px;
  gap: 12px;
}
#info.hidden { display: none; }
#modality-selector {
  display: flex;
  gap: 2px 4px;
  flex-wrap: wrap;
  align-items: center;
  align-content: center;
  min-width: 0;
}
#status {
  color: #888;
  flex: 1;
  min-width: 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 16px;
  line-height: 1.2;
}
#status-name {
  flex: 1;
  text-align: left;
  word-break: break-all;
}
#status-info {
  flex-shrink: 0;
  text-align: right;
  white-space: nowrap;
}
.modality-btn {
  display: inline-flex;
  align-items: center;
  padding: 4px 10px;
  border-radius: 4px;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: opacity 0.15s, transform 0.15s;
  border: none;
  color: #000;
  user-select: none;
  position: relative;
  flex-shrink: 0;
}
.modality-btn:hover {
  transform: scale(1.05);
}
.modality-btn.active {
  opacity: 1;
  box-shadow: 0 0 0 2px #fff;
}
.modality-btn.inactive {
  opacity: 0.4;
}
.modality-btn.unavailable {
  opacity: 0.5;
  text-decoration: line-through;
}
.modality-btn.unavailable.active {
  opacity: 0.7;
}
#help-btn {
  background: #444;
  color: #fff;
  width: 24px;
  height: 24px;
  padding: 0;
  border-radius: 50%;
  font-size: 14px;
  font-weight: bold;
  cursor: pointer;
  border: none;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}
#help-btn:hover {
  background: #555;
}
.reorder-btn {
  background: #444;
  color: #fff;
  width: 24px;
  height: 24px;
  padding: 0;
  border-radius: 4px;
  font-size: 14px;
  cursor: pointer;
  border: none;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}
.reorder-btn:hover {
  background: #555;
}
.reorder-btn:disabled {
  opacity: 0.3;
  cursor: default;
}
#reorder-buttons {
  display: flex;
  gap: 2px;
  flex-shrink: 0;
  align-items: center;
}
#help-modal {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.8);
  align-items: center;
  justify-content: center;
  z-index: 100;
}
#help-modal.active { display: flex; }
#help-modal .modal-content {
  max-width: 450px;
}
#help-modal h3 {
  color: #0af;
  margin-bottom: 15px;
}
#help-modal table {
  width: 100%;
  text-align: left;
  border-collapse: collapse;
}
#help-modal td {
  padding: 6px 8px;
  border-bottom: 1px solid #444;
}
#help-modal td:first-child {
  color: #0af;
  font-family: monospace;
  white-space: nowrap;
}

/* Progress bar */
#progress-container {
  position: absolute;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.8);
  border: 1px solid #444;
  border-radius: 8px;
  padding: 12px 20px;
  z-index: 50;
  display: none;
  min-width: 250px;
  text-align: center;
}
#progress-container.active { display: block; }
#progress-text {
  margin-bottom: 8px;
  font-size: 12px;
  color: #aaa;
}
#progress-bar {
  width: 100%;
  height: 6px;
  background: #333;
  border-radius: 3px;
  overflow: hidden;
}
#progress-fill {
  height: 100%;
  background: #0af;
  width: 0%;
  transition: width 0.1s;
}

/* Carousel styles */
#carousel {
  display: none;
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.85);
  border-right: 1px solid #333;
  overflow-y: auto;
  overflow-x: hidden;
  z-index: 10;
  scroll-behavior: auto;  /* Prevent smooth scroll during resize */
}
#carousel.active { display: block; }
#carousel.resizing .carousel-row,
#carousel.resizing .carousel-thumb {
  transition: none !important;  /* Disable transitions during resize */
}
#carousel::-webkit-scrollbar {
  width: 6px;
}
#carousel::-webkit-scrollbar-track {
  background: #1a1a1a;
}
#carousel::-webkit-scrollbar-thumb {
  background: #444;
  border-radius: 3px;
}
#carousel::-webkit-scrollbar-thumb:hover {
  background: #555;
}
.carousel-row {
  display: flex;
  gap: 2px;
  padding: 4px 6px;
  cursor: pointer;
  border-bottom: 1px solid #222;
  transition: background 0.15s;
}
.carousel-row:hover {
  background: rgba(255, 255, 255, 0.05);
}
.carousel-row.current {
  background: rgba(255, 255, 255, 0.1);
}
.carousel-thumb {
  object-fit: contain;
  background: #111;
  border-radius: 3px;
  border: 2px solid transparent;
  transition: border-color 0.15s, opacity 0.15s;
  opacity: 0.6;
  flex-shrink: 0;
}
.carousel-thumb:hover {
  opacity: 1;
}
.carousel-thumb.active {
  opacity: 1;
}
.carousel-thumb.selected {
  border-color: #f0f;
}
.carousel-thumb.placeholder {
  background: #1a1a1a;
  opacity: 0.5;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border: 2px solid #333;
}
.carousel-thumb.placeholder:hover {
  opacity: 0.7;
  border-color: #555;
}
.carousel-thumb.placeholder.selected {
  border-color: #f0f;
  opacity: 0.8;
}
.carousel-thumb.placeholder::after {
  content: '‚úï';
  color: #555;
  font-size: 18px;
  font-weight: bold;
}

/* Winner voting indicators */
.carousel-thumb-container {
  position: relative;
  flex-shrink: 0;
}
.winner-indicator {
  position: absolute;
  top: 2px;
  right: 2px;
  width: 7px;
  height: 7px;
  background: rgba(255, 255, 255, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.4);
  cursor: pointer;
  transition: all 0.15s;
  z-index: 5;
}
.winner-indicator:hover {
  background: rgba(255, 255, 255, 0.4);
  border-color: rgba(255, 255, 255, 0.6);
}
.winner-indicator.winner {
  background: #0f0;
  border-color: #fff;
  box-shadow: 0 0 3px rgba(0, 255, 0, 0.5);
}
.winner-indicator.winner:hover {
  background: #0c0;
  border-color: #fff;
}

/* Carousel resize handle */
#carousel-resize {
  display: none;
  position: absolute;
  left: 216px;  /* CAROUSEL_WIDTH - 4 */
  top: 0;
  bottom: 0;
  width: 8px;
  cursor: ew-resize;
  background: transparent;
  z-index: 11;
}
#carousel-resize.active {
  display: block;
}
#carousel-resize:hover,
#carousel-resize.dragging {
  background: rgba(0, 170, 255, 0.3);
}

#error-modal {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.8);
  align-items: center;
  justify-content: center;
  z-index: 100;
}
#error-modal.active { display: flex; }
.modal-content {
  background: #2a2a2a;
  padding: 30px;
  border-radius: 12px;
  text-align: center;
  max-width: 400px;
}
.modal-content h3 { margin-bottom: 15px; color: #f66; }
.modal-content p { margin-bottom: 20px; line-height: 1.6; }
.modal-buttons { display: flex; gap: 10px; justify-content: center; }
.btn {
  padding: 10px 24px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
}
.btn-primary { background: #0af; color: #000; }
.btn-secondary { background: #444; color: #fff; }
.btn:hover { opacity: 0.9; }

/* Crop / Delete buttons in floating panel */
#crop-btn, #delete-btn {
  padding: 3px 8px;
  background: #444;
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 11px;
}
#crop-btn:hover { background: #555; }
#crop-btn.active { background: #0af; color: #000; }
#delete-btn:hover { background: #a33; }

/* Crop overlay */
#crop-overlay {
  position: absolute;
  inset: 0;
  z-index: 15;
  cursor: crosshair;
}
.crop-dim {
  position: absolute;
  background: rgba(0, 0, 0, 0.5);
  pointer-events: none;
}
.crop-rect {
  position: absolute;
  border: 2px solid #0f0;
  box-sizing: border-box;
  pointer-events: none;
}
.crop-handle {
  position: absolute;
  width: 10px;
  height: 10px;
  background: #fff;
  border: 1px solid #333;
  border-radius: 2px;
  z-index: 16;
}
.crop-toolbar {
  position: absolute;
  transform: translateX(-50%);
  display: flex;
  gap: 4px;
  z-index: 16;
}
.crop-toolbar-btn {
  padding: 3px 10px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 11px;
}
.crop-confirm {
  background: #2ea043;
  color: #fff;
}
.crop-confirm:hover { background: #3fb950; }
.crop-cancel {
  background: #444;
  color: #fff;
}
.crop-cancel:hover { background: #555; }
</style>
</head>
<body>

<div id="dropzone">
  <div class="drop-text">
    <h2>Drop 2+ Images or a Folder <span id="dropzone-version" style="font-size: 12px; color: #666; font-weight: normal;"></span></h2>
    <p>Drop multiple images to form a tuple, or a folder with subdirectories as modalities</p>
    <p style="margin-top: 12px;">
      <button id="select-folder-btn" class="btn btn-primary">Select Folder</button>
    </p>
    <p style="margin-top: 20px; color: #666; font-size: 12px; line-height: 1.8;">
      ‚Üê‚Üí: modality | ‚Üë‚Üì: tuple | Space: flip | 1-9: jump to modality<br>
      [ ]: reorder modality | Enter: toggle winner | C: crop | Del: delete tuple<br>
      Scroll: zoom | Drag: pan | Esc: reset
    </p>
  </div>
</div>

<div id="viewer">
  <div id="carousel"></div>
  <div id="carousel-resize"></div>
  <div id="progress-container">
    <div id="progress-text">Loading thumbnails...</div>
    <div id="progress-bar"><div id="progress-fill"></div></div>
  </div>
  <canvas id="canvas"></canvas>
  <div id="floating-panel">
    <div id="fp-header">
      <span id="fp-title">Tools</span>
      <span id="fp-collapse-btn">&#9662;</span>
    </div>
    <div id="fp-body">
      <div id="fp-minimap">
        <canvas id="thumb-canvas"></canvas>
        <div id="thumb-viewport"></div>
      </div>
      <div id="fp-actions">
        <button id="crop-btn" title="Crop all modalities (C)">Crop</button>
        <button id="delete-btn" title="Delete current tuple files (Del)">Delete</button>
      </div>
    </div>
  </div>
</div>

<div id="info" class="hidden">
  <div id="reorder-buttons">
    <button id="reorder-left" class="reorder-btn" title="Move modality left ([)">‚Üê</button>
    <button id="reorder-right" class="reorder-btn" title="Move modality right (])">‚Üí</button>
  </div>
  <div id="modality-selector"></div>
  <span id="status"><span id="status-name">Loading...</span><span id="status-info"></span></span>
  <button id="help-btn" title="Keyboard shortcuts">?</button>
</div>

<div id="help-modal">
  <div class="modal-content">
    <h3>Keyboard Shortcuts <span id="help-version" style="font-size: 12px; color: #666; font-weight: normal;"></span></h3>
    <table>
      <tr><td>‚Üê ‚Üí</td><td>Switch modality</td></tr>
      <tr><td>‚Üë ‚Üì</td><td>Previous/next tuple</td></tr>
      <tr><td>Space</td><td>Flip to previous modality (hold)</td></tr>
      <tr><td>1-9</td><td>Jump to modality N</td></tr>
      <tr><td>[ ]</td><td>Reorder current modality</td></tr>
      <tr><td>Enter</td><td>Toggle winner for current modality</td></tr>
      <tr><td>Scroll</td><td>Zoom in/out</td></tr>
      <tr><td>Drag</td><td>Pan image</td></tr>
      <tr><td>C</td><td>Toggle crop mode</td></tr>
      <tr><td>Del</td><td>Delete current tuple</td></tr>
      <tr><td>Esc</td><td>Reset zoom (2x: back to start)</td></tr>
    </table>
    <div class="modal-buttons" style="margin-top: 20px;">
      <button class="btn btn-primary" onclick="closeHelpModal()">Close</button>
    </div>
  </div>
</div>

<div id="error-modal">
  <div class="modal-content">
    <h3>Aspect Ratio Mismatch</h3>
    <p id="error-text"></p>
    <div class="modal-buttons">
      <button class="btn btn-secondary" onclick="cancelLoad()">Cancel</button>
      <button class="btn btn-primary" onclick="continueLoad()">Continue Anyway</button>
    </div>
  </div>
</div>

<input type="file" id="file-input" accept="image/*" multiple style="display:none">
<input type="file" id="folder-input" webkitdirectory style="display:none">

<script>
// Version
const VERSION = 'v0.1.7';

// Debug logging - set to true to enable console diagnostics
const DEBUG = false;
function dbg(...args) { if (DEBUG) console.log('[ImageCompare]', ...args); }

// Set version in UI
document.getElementById('help-version').textContent = VERSION;
document.getElementById('dropzone-version').textContent = VERSION;

const dropzone = document.getElementById('dropzone');
const viewer = document.getElementById('viewer');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const info = document.getElementById('info');
const status = document.getElementById('status');
const statusName = document.getElementById('status-name');
const statusInfo = document.getElementById('status-info');
const modalitySelector = document.getElementById('modality-selector');
const errorModal = document.getElementById('error-modal');
const errorText = document.getElementById('error-text');
const fileInput = document.getElementById('file-input');
const floatingPanel = document.getElementById('floating-panel');
const fpMinimap = document.getElementById('fp-minimap');
const fpActions = document.getElementById('fp-actions');
const fpCollapseBtn = document.getElementById('fp-collapse-btn');
const thumbCanvas = document.getElementById('thumb-canvas');
const thumbCtx = thumbCanvas.getContext('2d');
const thumbViewport = document.getElementById('thumb-viewport');
const carousel = document.getElementById('carousel');
const carouselResize = document.getElementById('carousel-resize');
const progressContainer = document.getElementById('progress-container');
const progressText = document.getElementById('progress-text');
const progressFill = document.getElementById('progress-fill');

const THUMB_MAX_SIZE = 150;
const IMAGE_EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'bmp', 'webp', 'tiff', 'tif', 'ppmx'];

// Configurable carousel width - thumbnails scale proportionally
let CAROUSEL_WIDTH = 220;
let CAROUSEL_THUMB_SIZE = 50;  // Base size, will be recalculated

// Modality colors - cycle through these
const MODALITY_COLORS = [
  '#0f0',    // green
  '#f60',    // orange
  '#0af',    // cyan
  '#f0f',    // magenta
  '#ff0',    // yellow
  '#f44',    // red
  '#4f4',    // light green
  '#44f',    // blue
];

// Current tuple's images - array indexed by modality position
// May contain undefined for missing modalities
let images = [];  // images[modalityIndex] = {img, name, width, height, url, modality} or undefined
let currentModalityIndex = 0;  // Index into modalities array (display position)
let previousModalityIndex = 0;  // For spacebar flip behavior
let zoom = 1;
let panX = 0, panY = 0;
let isDragging = false;
let dragStartX, dragStartY;
let pendingImages = null;
let isReset = false;
let spaceDown = false;

// Multi-tuple mode
let tuples = [];
let currentTupleIndex = 0;
let modalities = [];  // Array of modality names
let modalityColors = [];  // Color assigned to each modality
let isMultiTupleMode = false;

// Winner voting state
let winners = new Map();  // tupleIndex -> modalityIndex
let votingEnabled = false;  // Only enabled in directory mode
let rootDirHandle = null;  // Directory handle for saving results.txt (File System Access API)
let modalityDirHandles = new Map();  // modalityName -> FileSystemDirectoryHandle
let pollTimer = null;  // Interval ID for file polling

// Crop tool state
let cropMode = false;

// Thumbnail cache: Map of File object -> canvas data URL (file-based key survives reordering)
const thumbnailCache = new WeakMap();

// Preloaded tuples cache: Map of tupleIdx -> loaded images array
const preloadedTuples = new Map();
const PRELOAD_AHEAD = 3;  // Number of tuples to preload ahead/behind

// Help modal
const helpModal = document.getElementById('help-modal');
const helpBtn = document.getElementById('help-btn');

helpBtn.addEventListener('click', () => {
  helpModal.classList.add('active');
});

const cropBtn = document.getElementById('crop-btn');
const deleteBtn = document.getElementById('delete-btn');

cropBtn.addEventListener('click', () => {
  if (cropMode) {
    exitCropMode(true);
  } else if (votingEnabled && isMultiTupleMode) {
    cropBtn.classList.add('active');
    enterCropMode();
  }
});

deleteBtn.addEventListener('click', () => {
  if (votingEnabled && isMultiTupleMode && !cropMode) {
    deleteTupleFiles();
  }
});

// Floating panel drag and collapse
let fpDragging = false;
let fpDragStartX = 0, fpDragStartY = 0;
let fpDragStartLeft = 0, fpDragStartTop = 0;
let fpDragMoved = false;

document.getElementById('fp-header').addEventListener('mousedown', (e) => {
  fpDragging = true;
  fpDragMoved = false;
  fpDragStartX = e.clientX;
  fpDragStartY = e.clientY;
  const rect = floatingPanel.getBoundingClientRect();
  fpDragStartLeft = rect.left;
  fpDragStartTop = rect.top;
  e.preventDefault();
});

document.addEventListener('mousemove', (e) => {
  if (!fpDragging) return;
  const dx = e.clientX - fpDragStartX;
  const dy = e.clientY - fpDragStartY;
  if (Math.abs(dx) > 3 || Math.abs(dy) > 3) fpDragMoved = true;
  if (fpDragMoved) {
    floatingPanel.style.right = 'auto';
    floatingPanel.style.left = (fpDragStartLeft + dx) + 'px';
    floatingPanel.style.top = (fpDragStartTop + dy) + 'px';
  }
});

document.addEventListener('mouseup', () => {
  if (fpDragging && !fpDragMoved) {
    // Click without drag = toggle collapse
    floatingPanel.classList.toggle('collapsed');
    fpCollapseBtn.textContent = floatingPanel.classList.contains('collapsed') ? '\u25b8' : '\u25be';
  }
  fpDragging = false;
});

function closeHelpModal() {
  helpModal.classList.remove('active');
}

// Reorder buttons
const reorderLeftBtn = document.getElementById('reorder-left');
const reorderRightBtn = document.getElementById('reorder-right');

reorderLeftBtn.addEventListener('click', () => moveCurrentModality(-1));
reorderRightBtn.addEventListener('click', () => moveCurrentModality(1));

// Keyboard navigation state
let isLoadingTuple = false;  // Prevent concurrent tuple loads
let lastKeyNavTime = 0;
const KEY_NAV_THROTTLE = 100;  // ms between tuple changes when holding key

// Drag and drop
dropzone.addEventListener('dragover', (e) => {
  e.preventDefault();
  dropzone.classList.add('dragover');
});

dropzone.addEventListener('dragleave', () => {
  dropzone.classList.remove('dragover');
});

dropzone.addEventListener('drop', async (e) => {
  e.preventDefault();
  dropzone.classList.remove('dragover');

  const items = e.dataTransfer.items;
  if (!items) {
    handleFiles(e.dataTransfer.files);
    return;
  }

  // Check if we have directories using the modern File System Access API
  const entries = [];
  for (let i = 0; i < items.length; i++) {
    const entry = items[i].webkitGetAsEntry ? items[i].webkitGetAsEntry() : null;
    if (entry) entries.push({ entry, item: items[i] });
  }

  const dirs = entries.filter(e => e.entry.isDirectory);

  if (dirs.length === 1 && entries.length === 1) {
    // Single directory - check for subdirectories as modalities
    try {
      if (items[0].getAsFileSystemHandle) {
        const handle = await items[0].getAsFileSystemHandle();
        if (handle.kind === 'directory') {
          await handleSingleDirectoryModern(handle);
          return;
        }
      }
    } catch (err) {
      console.warn('Modern API failed, trying legacy:', err);
    }

    // Fallback to legacy API
    try {
      await handleSingleDirectory(dirs[0].entry);
    } catch (err) {
      console.error('Directory handling error:', err);
      alert('Error reading directory. Try using Chrome or select files directly.');
    }
  } else if (dirs.length >= 2) {
    alert('Please drop a single folder with subdirectories as modalities, or multiple image files.');
  } else {
    // Regular files mode - form a single tuple
    handleFiles(e.dataTransfer.files);
  }
});

dropzone.addEventListener('click', (e) => {
  if (e.target.tagName === 'BUTTON') return;
  fileInput.click();
});
fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

// Folder selection via button
const selectFolderBtn = document.getElementById('select-folder-btn');
const folderInput = document.getElementById('folder-input');

selectFolderBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  folderInput.value = '';
  folderInput.click();
});

folderInput.addEventListener('change', async (e) => {
  if (e.target.files.length > 0) {
    await handleFolderInput(e.target.files);
  }
});

async function handleFolderInput(files) {
  // Group files by their immediate parent directory
  const filesByDir = new Map();

  for (const file of files) {
    const pathParts = file.webkitRelativePath.split('/');
    if (pathParts.length < 2) continue;

    // Check if it's in a subdirectory (pathParts.length >= 3 means root/subdir/file)
    if (pathParts.length >= 3) {
      const subdir = pathParts[1];
      if (!filesByDir.has(subdir)) {
        filesByDir.set(subdir, []);
      }
      const ext = file.name.split('.').pop().toLowerCase();
      if (IMAGE_EXTENSIONS.includes(ext)) {
        filesByDir.set(subdir, [...filesByDir.get(subdir), file]);
      }
    }
  }

  if (filesByDir.size < 2) {
    // No subdirectories, treat as single tuple
    const imageFiles = Array.from(files).filter(f => {
      const ext = f.name.split('.').pop().toLowerCase();
      return IMAGE_EXTENSIONS.includes(ext);
    });

    if (imageFiles.length >= 2) {
      await handleFilesAsTuple(imageFiles);
    } else {
      alert('Need at least 2 images or a folder with subdirectories as modalities');
    }
    return;
  }

  // Folder input doesn't provide directory handle for writing
  rootDirHandle = null;
  votingEnabled = false;
  winners = new Map();

  // Process subdirectories as modalities
  await processSubdirectoriesAsModalities(filesByDir);
}

async function handleSingleDirectory(dirEntry) {
  // Read subdirectories
  const subdirs = [];

  await new Promise((resolve, reject) => {
    const reader = dirEntry.createReader();

    function readBatch() {
      reader.readEntries((entries) => {
        if (entries.length === 0) {
          resolve();
          return;
        }
        for (const entry of entries) {
          if (entry.isDirectory) {
            subdirs.push(entry);
          }
        }
        readBatch();
      }, reject);
    }
    readBatch();
  });

  if (subdirs.length < 2) {
    alert('Folder must contain at least 2 subdirectories as modalities');
    return;
  }

  // Read files from each subdirectory
  const filesByDir = new Map();
  for (const subdir of subdirs) {
    const files = await readDirectory(subdir);
    if (files.length > 0) {
      filesByDir.set(subdir.name, files);
    }
  }

  if (filesByDir.size < 2) {
    alert('Need at least 2 subdirectories with images');
    return;
  }

  // Legacy API doesn't support directory handles for writing
  rootDirHandle = null;
  votingEnabled = false;
  winners = new Map();

  await processSubdirectoriesAsModalitiesLegacy(filesByDir);
}

async function handleSingleDirectoryModern(dirHandle) {
  const subdirs = [];

  for await (const entry of dirHandle.values()) {
    if (entry.kind === 'directory') {
      subdirs.push(entry);
    }
  }

  if (subdirs.length < 2) {
    alert('Folder must contain at least 2 subdirectories as modalities');
    return;
  }

  // Read files from each subdirectory
  const filesByDir = new Map();
  modalityDirHandles = new Map();
  for (const subdir of subdirs) {
    const files = await readDirectoryModern(subdir);
    if (files.length > 0) {
      filesByDir.set(subdir.name, files);
      modalityDirHandles.set(subdir.name, subdir);
    }
  }

  if (filesByDir.size < 2) {
    alert('Need at least 2 subdirectories with images');
    return;
  }

  // Store directory handle for saving results.txt
  rootDirHandle = dirHandle;
  votingEnabled = true;
  winners = new Map();

  await processSubdirectoriesAsModalitiesModern(filesByDir);

  // Load existing winners from results.txt
  await loadResults();

  // Start polling for external file changes
  startPolling();
}

async function processSubdirectoriesAsModalities(filesByDir) {
  // Sort modalities alphabetically
  modalities = Array.from(filesByDir.keys()).sort();
  modalityColors = modalities.map((_, i) => MODALITY_COLORS[i % MODALITY_COLORS.length]);

  // Use trie-based matching to group files into tuples
  const matchedTuples = matchTuplesWithTrie(filesByDir, modalities);

  if (matchedTuples.length === 0) {
    alert('No images found in modalities');
    return;
  }

  // Build tuples from matched files
  tuples = [];
  for (const matched of matchedTuples) {
    const tupleImages = [];
    const names = [];

    // Add files in modality order
    for (const modality of modalities) {
      const file = matched.files.get(modality);
      if (file) {
        tupleImages.push({
          file,
          modality
        });
        names.push(file.name);
      }
    }

    // Only create tuple if at least one image exists
    if (tupleImages.length > 0) {
      const tupleName = findCommonSubstring(names) || matched.key;
      tuples.push({
        name: tupleName,
        imageData: tupleImages
      });
    }
  }

  // Log info about partial tuples
  const partialCount = tuples.filter(t => t.imageData.length < modalities.length).length;
  if (partialCount > 0) {
    console.log(`${partialCount} tuples are missing some modalities`);
  }

  isMultiTupleMode = tuples.length > 1;
  currentTupleIndex = 0;

  // Calculate carousel thumb size based on number of modalities
  updateCarouselThumbSize();

  await loadTuple(0);
}

async function processSubdirectoriesAsModalitiesLegacy(filesByDir) {
  // Sort modalities alphabetically
  modalities = Array.from(filesByDir.keys()).sort();
  modalityColors = modalities.map((_, i) => MODALITY_COLORS[i % MODALITY_COLORS.length]);

  // Legacy format has {name, file} objects - convert to file-like with name property
  const filesByModality = new Map();
  for (const modality of modalities) {
    const files = filesByDir.get(modality);
    // Wrap legacy format: {name, file} -> file with .name accessible
    filesByModality.set(modality, files.map(fd => ({
      ...fd.file,
      name: fd.name,
      _originalFile: fd.file
    })));
  }

  // Use trie-based matching to group files into tuples
  const matchedTuples = matchTuplesWithTrie(filesByModality, modalities);

  if (matchedTuples.length === 0) {
    alert('No images found in modalities');
    return;
  }

  // Build tuples from matched files
  tuples = [];
  for (const matched of matchedTuples) {
    const tupleImages = [];
    const names = [];

    // Add files in modality order
    for (const modality of modalities) {
      const fileData = matched.files.get(modality);
      if (fileData) {
        tupleImages.push({
          file: fileData._originalFile || fileData,
          modality
        });
        names.push(fileData.name);
      }
    }

    // Only create tuple if at least one image exists
    if (tupleImages.length > 0) {
      const tupleName = findCommonSubstring(names) || matched.key;
      tuples.push({
        name: tupleName,
        imageData: tupleImages
      });
    }
  }

  // Log info about partial tuples
  const partialCount = tuples.filter(t => t.imageData.length < modalities.length).length;
  if (partialCount > 0) {
    console.log(`${partialCount} tuples are missing some modalities`);
  }

  isMultiTupleMode = tuples.length > 1;
  currentTupleIndex = 0;

  updateCarouselThumbSize();

  await loadTuple(0);
}

async function processSubdirectoriesAsModalitiesModern(filesByDir) {
  // Sort modalities alphabetically
  modalities = Array.from(filesByDir.keys()).sort();
  modalityColors = modalities.map((_, i) => MODALITY_COLORS[i % MODALITY_COLORS.length]);

  // Modern format has {name, file} objects - convert to file-like with name property
  const filesByModality = new Map();
  for (const modality of modalities) {
    const files = filesByDir.get(modality);
    // Wrap modern format: {name, file} -> file with .name accessible
    filesByModality.set(modality, files.map(fd => ({
      ...fd.file,
      name: fd.name,
      _originalFile: fd.file
    })));
  }

  // Use trie-based matching to group files into tuples
  const matchedTuples = matchTuplesWithTrie(filesByModality, modalities);

  if (matchedTuples.length === 0) {
    alert('No images found in modalities');
    return;
  }

  // Build tuples from matched files
  tuples = [];
  for (const matched of matchedTuples) {
    const tupleImages = [];
    const names = [];

    // Add files in modality order
    for (const modality of modalities) {
      const fileData = matched.files.get(modality);
      if (fileData) {
        tupleImages.push({
          file: fileData._originalFile || fileData,
          modality
        });
        names.push(fileData.name);
      }
    }

    // Only create tuple if at least one image exists
    if (tupleImages.length > 0) {
      const tupleName = findCommonSubstring(names) || matched.key;
      tuples.push({
        name: tupleName,
        imageData: tupleImages
      });
    }
  }

  // Log info about partial tuples
  const partialCount = tuples.filter(t => t.imageData.length < modalities.length).length;
  if (partialCount > 0) {
    dbg(`${partialCount} tuples are missing some modalities`);
  }
  dbg('Total tuples:', tuples.length, 'Modalities:', modalities);
  for (const t of tuples) {
    const mods = t.imageData.map(d => d.modality);
    if (mods.length < modalities.length) {
      dbg('  Partial tuple:', t.name, 'has:', mods.join(', '), 'missing:', modalities.filter(m => !mods.includes(m)).join(', '));
    }
  }

  isMultiTupleMode = tuples.length > 1;
  currentTupleIndex = 0;

  updateCarouselThumbSize();

  await loadTuple(0);
}

function updateCarouselThumbSize() {
  // Calculate thumb size so all modalities fit in carousel width
  // Account for padding (6px each side) and gaps (2px between thumbs)
  const numModalities = modalities.length;
  const availableWidth = CAROUSEL_WIDTH - 12 - (numModalities - 1) * 2;
  CAROUSEL_THUMB_SIZE = Math.floor(availableWidth / numModalities);
  CAROUSEL_THUMB_SIZE = Math.max(30, CAROUSEL_THUMB_SIZE);  // Minimum 30px, no maximum
}

// Find common substring among filenames (for tuple naming)
function findCommonSubstring(names) {
  if (names.length === 0) return '';
  if (names.length === 1) return names[0].replace(/\.[^.]+$/, '');  // Remove extension

  // Remove extensions
  const basenames = names.map(n => n.replace(/\.[^.]+$/, ''));

  // Find longest common substring
  let common = basenames[0];

  for (let i = 1; i < basenames.length; i++) {
    common = longestCommonSubstring(common, basenames[i]);
    if (!common) break;
  }

  // Clean up: remove trailing/leading underscores, dashes, spaces
  common = common.replace(/^[\s_-]+|[\s_-]+$/g, '');

  return common;
}

function longestCommonSubstring(s1, s2) {
  if (!s1 || !s2) return '';

  const len1 = s1.length;
  const len2 = s2.length;

  // Build matrix of common suffixes
  const dp = Array(len1 + 1).fill(null).map(() => Array(len2 + 1).fill(0));
  let maxLen = 0;
  let endPos = 0;

  for (let i = 1; i <= len1; i++) {
    for (let j = 1; j <= len2; j++) {
      if (s1[i-1] === s2[j-1]) {
        dp[i][j] = dp[i-1][j-1] + 1;
        if (dp[i][j] > maxLen) {
          maxLen = dp[i][j];
          endPos = i;
        }
      }
    }
  }

  return s1.substring(endPos - maxLen, endPos);
}

// Find difference in filenames (for modality naming when dropping files)
function findDifferingParts(names) {
  if (names.length < 2) return names;

  // Remove extensions
  const basenames = names.map(n => n.replace(/\.[^.]+$/, ''));

  // Find common prefix and suffix
  let prefix = basenames[0];
  let suffix = basenames[0];

  for (const name of basenames) {
    // Find common prefix
    let i = 0;
    while (i < prefix.length && i < name.length && prefix[i] === name[i]) i++;
    prefix = prefix.substring(0, i);

    // Find common suffix
    let j = 0;
    while (j < suffix.length && j < name.length &&
           suffix[suffix.length - 1 - j] === name[name.length - 1 - j]) j++;
    suffix = suffix.substring(suffix.length - j);
  }

  // Extract the differing parts
  return basenames.map(name => {
    let diff = name.substring(prefix.length, name.length - suffix.length);
    // Clean up
    diff = diff.replace(/^[\s_-]+|[\s_-]+$/g, '');
    return diff || name;
  });
}

async function readDirectory(dirEntry) {
  const allEntries = [];

  await new Promise((resolve, reject) => {
    const reader = dirEntry.createReader();

    function readBatch() {
      reader.readEntries((entries) => {
        if (entries.length === 0) {
          resolve();
          return;
        }
        for (const entry of entries) {
          if (entry.isFile) {
            const ext = entry.name.split('.').pop().toLowerCase();
            if (IMAGE_EXTENSIONS.includes(ext)) {
              allEntries.push(entry);
            }
          }
        }
        readBatch();
      }, (err) => {
        console.error('readEntries error:', err);
        reject(err);
      });
    }
    readBatch();
  });

  // Convert entries to files
  const allFiles = [];
  for (const entry of allEntries) {
    try {
      const file = await getFileFromEntry(entry);
      if (file) {
        allFiles.push({ name: entry.name, file });
      }
    } catch (err) {
      console.warn(`Skipping ${entry.name}:`, err);
    }
  }

  return allFiles;
}

function getFileFromEntry(entry) {
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error('Timeout reading file'));
    }, 5000);

    try {
      entry.file(
        (file) => {
          clearTimeout(timeout);
          resolve(file);
        },
        (err) => {
          clearTimeout(timeout);
          reject(err);
        }
      );
    } catch (err) {
      clearTimeout(timeout);
      reject(err);
    }
  });
}

function naturalSort(a, b) {
  return a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' });
}

// Strip file extension
function stripExtension(filename) {
  return filename.replace(/\.[^.]+$/, '');
}

// Longest Common Subsequence length for tie-breaking
// Uses O(n) space with two-row optimization
function lcsLength(a, b) {
  const m = a.length, n = b.length;
  let prev = new Array(n + 1).fill(0);
  let curr = new Array(n + 1).fill(0);

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (a[i-1] === b[j-1]) {
        curr[j] = prev[j-1] + 1;
      } else {
        curr[j] = Math.max(prev[j], curr[j-1]);
      }
    }
    [prev, curr] = [curr, prev];
  }

  return prev[n];
}

// Trie-based tuple matching with LCP scoring and LCS tie-breaking
//
// Algorithm:
// 1. Pick reference modality (one with most files)
// 2. Build trie from reference filenames - each node tracks which files pass through
// 3. For each file in other modalities:
//    - Walk trie to find longest matching prefix (LCP)
//    - Collect candidate reference files at deepest matched node
//    - Use LCS (longest common subsequence) as tie-breaker
// 4. Group files by their matched reference file
//
// Complexity: O(N * L) for trie ops, O(ties * L¬≤) for LCS tie-breaking
// where N = total files, L = max filename length
function matchTuplesWithTrie(filesByModality, modalityNames) {
  if (modalityNames.length < 2) {
    // Single modality - return each file as its own tuple
    if (modalityNames.length === 1) {
      const mod = modalityNames[0];
      const files = filesByModality.get(mod) || [];
      return files.map(f => ({
        key: stripExtension(f.name),
        files: new Map([[mod, f]])
      }));
    }
    return [];
  }

  // Pick reference modality (most files) - ensures best coverage
  let refMod = modalityNames[0];
  let maxCount = (filesByModality.get(refMod) || []).length;
  for (const mod of modalityNames) {
    const count = (filesByModality.get(mod) || []).length;
    if (count > maxCount) {
      maxCount = count;
      refMod = mod;
    }
  }

  const refFiles = filesByModality.get(refMod) || [];
  if (refFiles.length === 0) return [];

  // Build trie from reference filenames
  // Each node has: children (Map), indices (array of refFile indices that pass through)
  const trie = { children: new Map(), indices: [] };

  for (let i = 0; i < refFiles.length; i++) {
    const key = stripExtension(refFiles[i].name);
    let node = trie;
    // Add index at root level too (for files with no common prefix)
    node.indices.push(i);

    for (const char of key) {
      if (!node.children.has(char)) {
        node.children.set(char, { children: new Map(), indices: [] });
      }
      node = node.children.get(char);
      node.indices.push(i);
    }
  }

  // Build a lookup from ref basename -> ref index for exact matching
  const refBaseToIdx = new Map();
  for (let i = 0; i < refFiles.length; i++) {
    refBaseToIdx.set(stripExtension(refFiles[i].name), i);
  }

  // Create tuple map: refIndex -> Map(modality -> file)
  const tupleMap = new Map();
  for (let i = 0; i < refFiles.length; i++) {
    tupleMap.set(i, new Map([[refMod, refFiles[i]]]));
  }

  // Track which ref indices have at least one exact match from another modality.
  // These are "claimed" by exact matches and should be excluded from fuzzy matching.
  const exactMatchedRefs = new Set();

  // Pass 1: exact matches (identical basenames across modalities, e.g. crop files)
  for (const mod of modalityNames) {
    if (mod === refMod) continue;
    const files = filesByModality.get(mod) || [];
    for (const file of files) {
      const query = stripExtension(file.name);
      const exactIdx = refBaseToIdx.get(query);
      if (exactIdx !== undefined) {
        tupleMap.get(exactIdx).set(mod, file);
        exactMatchedRefs.add(exactIdx);
      }
    }
  }

  dbg('Two-pass matching:', exactMatchedRefs.size, 'exact matches,', refFiles.length - exactMatchedRefs.size, 'remaining for fuzzy');

  // Pass 2: fuzzy matches via trie (for files without exact ref match)
  for (const mod of modalityNames) {
    if (mod === refMod) continue;

    const files = filesByModality.get(mod) || [];
    for (const file of files) {
      const query = stripExtension(file.name);
      // Skip if already matched exactly in pass 1
      if (refBaseToIdx.has(query)) continue;

      // Walk trie to find deepest matching node (longest common prefix)
      let node = trie;
      let bestNode = trie;

      for (const char of query) {
        if (!node.children.has(char)) break;
        node = node.children.get(char);
        if (node.indices.length > 0) {
          bestNode = node;
        }
      }

      // Prefer unclaimed refs, but fall back to all candidates if all are claimed
      let candidates = bestNode.indices.filter(i => !exactMatchedRefs.has(i));
      if (candidates.length === 0) candidates = bestNode.indices;
      if (candidates.length === 0) continue;

      // Find best match among candidates
      let bestIdx = candidates[0];

      if (candidates.length > 1) {
        // Tie-breaker: prefer shorter length difference, then LCS score
        let bestLenDiff = Infinity;
        let bestLcs = -1;
        for (const idx of candidates) {
          const refName = stripExtension(refFiles[idx].name);
          const lenDiff = Math.abs(refName.length - query.length);
          const score = lcsLength(query, refName);
          if (lenDiff < bestLenDiff || (lenDiff === bestLenDiff && score > bestLcs)) {
            bestLenDiff = lenDiff;
            bestLcs = score;
            bestIdx = idx;
          }
        }
      }

      // Add to tuple
      tupleMap.get(bestIdx).set(mod, file);
    }
  }

  // Convert to array format expected by the caller
  const result = [];
  for (const [idx, filesMap] of tupleMap) {
    result.push({
      key: stripExtension(refFiles[idx].name),
      files: filesMap
    });
  }

  // Sort by key for consistent ordering
  result.sort((a, b) =>
    a.key.localeCompare(b.key, undefined, { numeric: true, sensitivity: 'base' })
  );

  return result;
}

async function readDirectoryModern(dirHandle) {
  const files = [];
  for await (const entry of dirHandle.values()) {
    if (entry.kind === 'file') {
      const ext = entry.name.split('.').pop().toLowerCase();
      if (IMAGE_EXTENSIONS.includes(ext)) {
        try {
          const file = await entry.getFile();
          files.push({ name: entry.name, file });
        } catch (err) {
          console.warn(`Skipping ${entry.name}:`, err);
        }
      }
    }
  }
  return files;
}

// File polling - periodically re-scan directories for external changes
const POLL_INTERVAL = 2000; // ms

function startPolling() {
  stopPolling();
  if (!votingEnabled || modalityDirHandles.size === 0) return;
  dbg('Starting file polling');
  pollTimer = setInterval(() => pollDirectories(), POLL_INTERVAL);
}

function stopPolling() {
  if (pollTimer) {
    clearInterval(pollTimer);
    pollTimer = null;
    dbg('Stopped file polling');
  }
}

let isPolling = false;  // Guard against concurrent polls

async function pollDirectories() {
  if (isPolling || !votingEnabled || modalityDirHandles.size === 0) return;
  isPolling = true;

  try {
    // Re-read all modality directories
    const filesByDir = new Map();
    for (const [modName, dirHandle] of modalityDirHandles) {
      const files = await readDirectoryModern(dirHandle);
      if (files.length > 0) {
        filesByDir.set(modName, files);
      }
    }

    if (filesByDir.size < 2) {
      isPolling = false;
      return;
    }

    // Build a fingerprint of current state (sorted filenames per modality)
    const currentFingerprint = buildFingerprint(tuples, modalities);

    // Re-run tuple matching
    const sortedModalities = Array.from(filesByDir.keys()).sort();

    // Wrap files for matching (same format as processSubdirectoriesAsModalitiesModern)
    const filesByModality = new Map();
    for (const mod of sortedModalities) {
      const files = filesByDir.get(mod);
      filesByModality.set(mod, files.map(fd => ({
        ...fd.file,
        name: fd.name,
        _originalFile: fd.file
      })));
    }

    const matchedTuples = matchTuplesWithTrie(filesByModality, sortedModalities);

    // Build new tuples
    const newTuples = [];
    for (const matched of matchedTuples) {
      const tupleImages = [];
      const names = [];
      for (const mod of sortedModalities) {
        const fileData = matched.files.get(mod);
        if (fileData) {
          tupleImages.push({
            file: fileData._originalFile || fileData,
            modality: mod
          });
          names.push(fileData.name);
        }
      }
      if (tupleImages.length > 0) {
        const tupleName = findCommonSubstring(names) || matched.key;
        newTuples.push({ name: tupleName, imageData: tupleImages });
      }
    }

    // Build fingerprint for new state
    const newFingerprint = buildFingerprintFromTuples(newTuples, sortedModalities);

    if (currentFingerprint === newFingerprint) {
      isPolling = false;
      return;  // No changes
    }

    dbg('Poll detected changes, updating state');
    dbg('Old tuples:', tuples.length, '-> New tuples:', newTuples.length);

    // Remap winners by tuple name
    const winnersByName = new Map();
    for (const [tIdx, mIdx] of winners) {
      if (tuples[tIdx]) {
        winnersByName.set(tuples[tIdx].name, modalities[mIdx]);
      }
    }

    // Check if modalities changed
    const modalitiesChanged = JSON.stringify(modalities) !== JSON.stringify(sortedModalities);
    if (modalitiesChanged) {
      modalities = sortedModalities;
      modalityColors = modalities.map((_, i) => MODALITY_COLORS[i % MODALITY_COLORS.length]);
      updateCarouselThumbSize();
    }

    tuples = newTuples;

    // Restore winners by name
    winners = new Map();
    for (let i = 0; i < tuples.length; i++) {
      const winnerName = winnersByName.get(tuples[i].name);
      if (winnerName) {
        const mIdx = modalities.indexOf(winnerName);
        if (mIdx !== -1) winners.set(i, mIdx);
      }
    }

    // Clear preloaded tuples (file references may have changed)
    for (const [_, imgs] of preloadedTuples.entries()) {
      if (imgs) imgs.forEach(img => { if (img && img.url) URL.revokeObjectURL(img.url); });
    }
    preloadedTuples.clear();

    // Adjust current tuple index
    isMultiTupleMode = tuples.length > 1;
    if (currentTupleIndex >= tuples.length) {
      currentTupleIndex = Math.max(0, tuples.length - 1);
    }

    if (tuples.length === 0) {
      // All tuples gone - return to dropzone
      stopPolling();
      resetToDropzone();
    } else {
      // Rebuild carousel and reload current tuple
      buildCarousel();
      await loadTuple(currentTupleIndex);
    }
  } catch (err) {
    dbg('Poll error:', err);
  }

  isPolling = false;
}

function buildFingerprint(currentTuples, currentModalities) {
  const parts = [];
  for (const tuple of currentTuples) {
    const files = [];
    for (const imgData of tuple.imageData) {
      files.push(`${imgData.modality}:${imgData.file.name}:${imgData.file.size}`);
    }
    files.sort();
    parts.push(tuple.name + '|' + files.join(','));
  }
  parts.sort();
  return currentModalities.join('/') + '::' + parts.join(';;');
}

function buildFingerprintFromTuples(newTuples, newModalities) {
  const parts = [];
  for (const tuple of newTuples) {
    const files = [];
    for (const imgData of tuple.imageData) {
      files.push(`${imgData.modality}:${imgData.file.name}:${imgData.file.size}`);
    }
    files.sort();
    parts.push(tuple.name + '|' + files.join(','));
  }
  parts.sort();
  return newModalities.join('/') + '::' + parts.join(';;');
}

// Delete current tuple's files
async function deleteTupleFiles() {
  if (!votingEnabled || !isMultiTupleMode) return;

  const tuple = tuples[currentTupleIndex];
  if (!tuple) return;

  dbg('Deleting tuple', currentTupleIndex, tuple.name);

  // Pause polling to avoid races with file deletion
  stopPolling();

  // Delete files via File System Access API
  for (const imgData of tuple.imageData) {
    const dirHandle = modalityDirHandles.get(imgData.modality);
    if (!dirHandle) continue;
    try {
      await dirHandle.removeEntry(imgData.file.name);
      dbg('Deleted', imgData.file.name, 'from', imgData.modality);
    } catch (err) {
      console.warn(`Failed to delete ${imgData.file.name}:`, err);
    }
  }

  // Remove from state immediately (don't wait for poll)
  removeTupleFromState(currentTupleIndex);

  // Resume polling
  startPolling();
}

function removeTupleFromState(tupleIndex) {
  tuples.splice(tupleIndex, 1);

  // Clean up preloaded tuples
  preloadedTuples.delete(tupleIndex);
  const newPreloaded = new Map();
  for (const [idx, imgs] of preloadedTuples) {
    if (idx > tupleIndex) newPreloaded.set(idx - 1, imgs);
    else if (idx < tupleIndex) newPreloaded.set(idx, imgs);
  }
  preloadedTuples.clear();
  for (const [idx, imgs] of newPreloaded) preloadedTuples.set(idx, imgs);

  // Re-index winners
  const newWinners = new Map();
  for (const [tIdx, mIdx] of winners) {
    if (tIdx > tupleIndex) newWinners.set(tIdx - 1, mIdx);
    else if (tIdx < tupleIndex) newWinners.set(tIdx, mIdx);
  }
  winners = newWinners;
  saveResults();

  // Adjust current index
  if (currentTupleIndex >= tuples.length) {
    currentTupleIndex = Math.max(0, tuples.length - 1);
  }

  isMultiTupleMode = tuples.length > 1;

  if (tuples.length > 0) {
    buildCarousel();
    loadTuple(currentTupleIndex);
  } else {
    resetToDropzone();
  }
}

function resetToDropzone() {
  images.forEach(img => { if (img && img.url) URL.revokeObjectURL(img.url); });
  images = [];
  tuples = [];
  modalities = [];
  modalityColors = [];
  isMultiTupleMode = false;
  currentModalityIndex = 0;
  previousModalityIndex = 0;
  currentTupleIndex = 0;
  isReset = false;
  winners = new Map();
  votingEnabled = false;
  rootDirHandle = null;
  modalityDirHandles = new Map();
  stopPolling();
  if (cropMode) exitCropMode(true);
  viewer.classList.remove('active');
  dropzone.classList.remove('hidden');
  info.classList.add('hidden');
  floatingPanel.classList.remove('active');
  floatingPanel.classList.remove('collapsed');
  floatingPanel.style.right = '10px';
  floatingPanel.style.left = '';
  floatingPanel.style.top = '10px';
  fpCollapseBtn.textContent = '\u25be';
  carousel.classList.remove('active');
  carouselResize.classList.remove('active');
  carousel.innerHTML = '';
  progressContainer.classList.remove('active');
  for (const [_, imgs] of preloadedTuples.entries()) {
    if (imgs) imgs.forEach(img => { if (img && img.url) URL.revokeObjectURL(img.url); });
  }
  preloadedTuples.clear();
}

// Winner voting functions

/**
 * Toggle winner for current tuple/modality
 */
function toggleWinner(tupleIndex, modalityIndex) {
  if (!votingEnabled) return;

  const currentWinner = winners.get(tupleIndex);

  if (currentWinner === modalityIndex) {
    // Already winner - clear it
    winners.delete(tupleIndex);
  } else {
    // Set as winner
    winners.set(tupleIndex, modalityIndex);
  }

  // Update UI
  updateCarouselWinners();
  updateModalitySelector();

  // Save to file
  saveResults();
}

/**
 * Update winner indicators in carousel
 */
function updateCarouselWinners() {
  if (!isMultiTupleMode || !votingEnabled) return;

  const indicators = carousel.querySelectorAll('.winner-indicator');
  indicators.forEach((indicator) => {
    const tupleIdx = parseInt(indicator.dataset.tupleIndex);
    const modIdx = parseInt(indicator.dataset.modalityIndex);

    const winnerModalityIdx = winners.get(tupleIdx);
    if (winnerModalityIdx === modIdx) {
      indicator.classList.add('winner');
    } else {
      indicator.classList.remove('winner');
    }
  });
}

/**
 * Save winners to results.txt using File System Access API
 */
async function saveResults() {
  if (!rootDirHandle || !votingEnabled) return;

  try {
    // If no winners, delete the file
    if (winners.size === 0) {
      try {
        await rootDirHandle.removeEntry('results.txt');
      } catch {
        // File doesn't exist - that's OK
      }
      return;
    }

    // Build file content
    const lines = [
      '# ImageCompare Results',
      `# Generated: ${new Date().toISOString()}`,
      `# Modalities: ${modalities.join(', ')}`,
      '#',
      '# Format: tuple_key = winner_modality',
      '# Delete a line to remove the vote, edit modality name to change vote',
      ''
    ];

    // Sort winners by tuple index for consistent output
    const sortedWinners = Array.from(winners.entries()).sort((a, b) => a[0] - b[0]);

    for (const [tupleIndex, modalityIndex] of sortedWinners) {
      const tuple = tuples[tupleIndex];
      const modalityName = modalities[modalityIndex];
      if (tuple && modalityName) {
        lines.push(`${tuple.name} = ${modalityName}`);
      }
    }

    const content = lines.join('\n') + '\n';

    // Write to file
    const fileHandle = await rootDirHandle.getFileHandle('results.txt', { create: true });
    const writable = await fileHandle.createWritable();
    await writable.write(content);
    await writable.close();

    console.log('Saved results.txt');
  } catch (err) {
    console.warn('Failed to save results.txt:', err);
  }
}

/**
 * Load winners from results.txt
 */
async function loadResults() {
  if (!rootDirHandle || !votingEnabled) return;

  try {
    const fileHandle = await rootDirHandle.getFileHandle('results.txt');
    const file = await fileHandle.getFile();
    const content = await file.text();

    // Parse file
    const savedWinners = new Map();  // tupleName -> modalityName
    const lines = content.split('\n');

    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith('#')) continue;

      const eqIndex = trimmed.indexOf('=');
      if (eqIndex === -1) continue;

      const tupleKey = trimmed.substring(0, eqIndex).trim();
      const modalityName = trimmed.substring(eqIndex + 1).trim();

      if (tupleKey && modalityName) {
        savedWinners.set(tupleKey, modalityName);
      }
    }

    // Map saved winners to indices
    winners = new Map();
    for (let tupleIndex = 0; tupleIndex < tuples.length; tupleIndex++) {
      const tuple = tuples[tupleIndex];
      const winnerName = savedWinners.get(tuple.name);
      if (winnerName) {
        const modalityIndex = modalities.indexOf(winnerName);
        if (modalityIndex !== -1) {
          winners.set(tupleIndex, modalityIndex);
        }
      }
    }

    console.log(`Loaded ${winners.size} winners from results.txt`);

    // Update UI
    updateCarouselWinners();
    updateModalitySelector();
  } catch (err) {
    // File doesn't exist or can't be read - that's OK
    console.log('No results.txt found or failed to load');
  }
}

// Generate thumbnail data URL from file using createImageBitmap for non-blocking decode
async function generateThumbnail(file, size) {
  const ext = file.name.split('.').pop().toLowerCase();

  // Handle PPMX files specially - load via loadPpmx then scale
  if (ext === 'ppmx') {
    try {
      const { img, width, height, url } = await loadPpmx(file);
      const scale = Math.min(size / width, size / height);
      const w = Math.round(width * scale);
      const h = Math.round(height * scale);

      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, w, h);
      URL.revokeObjectURL(url);
      return canvas.toDataURL('image/jpeg', 0.7);
    } catch (err) {
      console.warn('Failed to generate PPMX thumbnail:', err);
      throw err;
    }
  }

  try {
    // createImageBitmap decodes off the main thread
    const bitmap = await createImageBitmap(file);

    // Calculate scaled size maintaining aspect ratio
    const scale = Math.min(size / bitmap.width, size / bitmap.height);
    const w = Math.round(bitmap.width * scale);
    const h = Math.round(bitmap.height * scale);

    // Use OffscreenCanvas if available for fully off-thread rendering
    let canvas, ctx;
    if (typeof OffscreenCanvas !== 'undefined') {
      canvas = new OffscreenCanvas(w, h);
      ctx = canvas.getContext('2d');
      ctx.drawImage(bitmap, 0, 0, w, h);
      const blob = await canvas.convertToBlob({ type: 'image/jpeg', quality: 0.7 });
      bitmap.close();
      return URL.createObjectURL(blob);
    } else {
      // Fallback for browsers without OffscreenCanvas
      canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      ctx = canvas.getContext('2d');
      ctx.drawImage(bitmap, 0, 0, w, h);
      bitmap.close();
      return canvas.toDataURL('image/jpeg', 0.7);
    }
  } catch (err) {
    // Fallback to traditional method
    return new Promise((resolve, reject) => {
      const img = new Image();
      const url = URL.createObjectURL(file);

      img.onload = () => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const scale = Math.min(size / img.width, size / img.height);
        const w = Math.round(img.width * scale);
        const h = Math.round(img.height * scale);
        canvas.width = w;
        canvas.height = h;
        ctx.drawImage(img, 0, 0, w, h);
        const dataUrl = canvas.toDataURL('image/jpeg', 0.7);
        URL.revokeObjectURL(url);
        resolve(dataUrl);
      };

      img.onerror = () => {
        URL.revokeObjectURL(url);
        reject(new Error('Failed to load image for thumbnail'));
      };

      img.src = url;
    });
  }
}

// Preload a tuple's full images (indexed by modality position)
async function preloadTupleImages(tupleIdx) {
  if (tupleIdx < 0 || tupleIdx >= tuples.length) return null;
  if (preloadedTuples.has(tupleIdx)) return preloadedTuples.get(tupleIdx);

  const tuple = tuples[tupleIdx];

  try {
    // Build a map of modality -> imageData for this tuple
    const imageDataByModality = new Map();
    for (const imgData of tuple.imageData) {
      imageDataByModality.set(imgData.modality, imgData);
    }

    // Load images indexed by modality position (undefined for missing)
    const loadedImages = await Promise.all(
      modalities.map(async (modalityName) => {
        const imgData = imageDataByModality.get(modalityName);
        if (!imgData) {
          return undefined;  // Missing modality
        }
        const loaded = await loadImage(imgData.file);
        loaded.modality = modalityName;
        return loaded;
      })
    );

    preloadedTuples.set(tupleIdx, loadedImages);
    return loadedImages;
  } catch (err) {
    console.warn(`Failed to preload tuple ${tupleIdx}:`, err);
    return null;
  }
}

// Preload tuples around current position
function triggerPreload(centerIdx) {
  // Preload ahead and behind
  for (let offset = 1; offset <= PRELOAD_AHEAD; offset++) {
    const ahead = centerIdx + offset;
    const behind = centerIdx - offset;

    if (ahead < tuples.length && !preloadedTuples.has(ahead)) {
      preloadTupleImages(ahead);
    }
    if (behind >= 0 && !preloadedTuples.has(behind)) {
      preloadTupleImages(behind);
    }
  }

  // Clean up old preloaded tuples that are too far away
  for (const [idx, imgs] of preloadedTuples.entries()) {
    if (Math.abs(idx - centerIdx) > PRELOAD_AHEAD + 2) {
      // Revoke URLs (skip undefined entries)
      if (imgs) {
        imgs.forEach(img => { if (img && img.url) URL.revokeObjectURL(img.url); });
      }
      preloadedTuples.delete(idx);
    }
  }
}

async function loadTuple(index) {
  if (index < 0 || index >= tuples.length) return;

  // Preserve current modality index when switching tuples
  const preservedModalityIndex = currentModalityIndex;

  currentTupleIndex = index;
  const tuple = tuples[index];

  // Build a map of modality -> imageData for this tuple
  const imageDataByModality = new Map();
  for (const imgData of tuple.imageData) {
    imageDataByModality.set(imgData.modality, imgData);
  }

  // Load images into an array indexed by modality position
  // Missing modalities will be undefined
  const loadedImages = await Promise.all(
    modalities.map(async (modalityName) => {
      const imgData = imageDataByModality.get(modalityName);
      if (!imgData) {
        return undefined;  // Missing modality
      }
      try {
        const loaded = await loadImage(imgData.file);
        loaded.modality = modalityName;
        return loaded;
      } catch (err) {
        dbg('Failed to load image for modality', modalityName, ':', err.message);
        return undefined;  // Treat as missing
      }
    })
  );

  // Check aspect ratios for available images
  const availableImages = loadedImages.filter(img => img !== undefined);
  if (availableImages.length === 0) {
    dbg('No images could be loaded for tuple', index);
    return;
  }

  const aspects = availableImages.map(img => img.width / img.height);
  const baseAspect = aspects[0];
  const tolerance = 0.01;

  const mismatch = aspects.find((a, i) =>
    i > 0 && Math.abs(a - baseAspect) / Math.max(a, baseAspect) > tolerance
  );

  if (mismatch !== undefined) {
    console.warn(`Aspect ratio mismatch in tuple ${index + 1}`);
    const details = availableImages.map(img =>
      `${img.modality}: ${img.width}√ó${img.height}`
    ).join(', ');
    console.warn(details);
  }

  activateViewer(loadedImages, tuple.name, preservedModalityIndex);

  // Trigger preloading of nearby tuples
  triggerPreload(index);
}

function handleFiles(files) {
  const imageFiles = Array.from(files).filter(f => {
    const ext = f.name.split('.').pop().toLowerCase();
    return f.type.startsWith('image/') || IMAGE_EXTENSIONS.includes(ext);
  });

  if (imageFiles.length < 2) {
    alert('Please drop at least 2 images to form a tuple');
    return;
  }

  handleFilesAsTuple(imageFiles);
}

async function handleFilesAsTuple(imageFiles) {
  // Sort files
  imageFiles.sort((a, b) => naturalSort({ name: a.name }, { name: b.name }));

  // Determine modalities from differing parts of filenames
  const names = imageFiles.map(f => f.name);
  modalities = findDifferingParts(names);
  modalityColors = modalities.map((_, i) => MODALITY_COLORS[i % MODALITY_COLORS.length]);

  // File mode doesn't support voting (no directory to save to)
  rootDirHandle = null;
  votingEnabled = false;
  winners = new Map();

  // Ensure unique modality names
  const seen = new Map();
  modalities = modalities.map((m, i) => {
    if (seen.has(m)) {
      const count = seen.get(m) + 1;
      seen.set(m, count);
      return `${m} (${count})`;
    }
    seen.set(m, 1);
    return m;
  });

  try {
    const loadedImages = await Promise.all(
      imageFiles.map(async (file, i) => {
        const loaded = await loadImage(file);
        loaded.modality = modalities[i];
        return loaded;
      })
    );

    // Check aspect ratios
    checkAndLoadTuple(loadedImages);
  } catch (err) {
    alert('Error loading images: ' + err.message);
  }
}

// Load a .ppmx file (custom float32 format) and convert to grayscale image
async function loadPpmx(file) {
  const buffer = await file.arrayBuffer();
  const bytes = new Uint8Array(buffer);

  // Find line breaks to parse header
  let pos = 0;
  const lines = [];
  for (let i = 0; i < 3; i++) {
    let lineEnd = pos;
    while (lineEnd < bytes.length && bytes[lineEnd] !== 10) lineEnd++;
    const line = new TextDecoder().decode(bytes.slice(pos, lineEnd));
    lines.push(line.trim());
    pos = lineEnd + 1;
  }

  const [header, dims, flags] = lines;

  // Validate header
  if (header !== 'P7') {
    throw new Error(`Unexpected PPMX header: "${header}", expected "P7"`);
  }

  // Parse dimensions
  const [w, h] = dims.split(/\s+/).map(Number);
  if (!w || !h) {
    throw new Error(`Invalid PPMX dimensions: "${dims}"`);
  }

  // Validate flags (currently only "00000000000" is known)
  const KNOWN_FLAGS = new Set(['00000000000']);
  if (!KNOWN_FLAGS.has(flags)) {
    console.warn(`Unknown PPMX flags: "${flags}". Known flags: ${[...KNOWN_FLAGS].join(', ')}`);
  }

  // Read float32 data
  const dataBuffer = buffer.slice(pos);
  const floatData = new Float32Array(dataBuffer);

  if (floatData.length !== w * h) {
    throw new Error(`PPMX data size mismatch: expected ${w * h}, got ${floatData.length}`);
  }

  // Find min/max for normalization
  let min = Infinity, max = -Infinity;
  for (let i = 0; i < floatData.length; i++) {
    const v = floatData[i];
    if (isFinite(v)) {
      if (v < min) min = v;
      if (v > max) max = v;
    }
  }

  // Create grayscale image
  const canvas = document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;
  const ctx = canvas.getContext('2d');
  const imageData = ctx.createImageData(w, h);
  const pixels = imageData.data;

  const range = max - min || 1;
  for (let i = 0; i < floatData.length; i++) {
    const v = floatData[i];
    const normalized = isFinite(v) ? (v - min) / range : 0;
    const gray = Math.round(normalized * 255);
    const pi = i * 4;
    pixels[pi] = gray;     // R
    pixels[pi + 1] = gray; // G
    pixels[pi + 2] = gray; // B
    pixels[pi + 3] = 255;  // A
  }

  ctx.putImageData(imageData, 0, 0);

  // Convert canvas to blob URL for consistent handling
  return new Promise((resolve, reject) => {
    canvas.toBlob((blob) => {
      if (!blob) {
        reject(new Error('Failed to create blob from PPMX'));
        return;
      }
      const url = URL.createObjectURL(blob);
      const img = new Image();
      img.onload = () => {
        resolve({ img, name: file.name, width: w, height: h, url });
      };
      img.onerror = () => {
        URL.revokeObjectURL(url);
        reject(new Error(`Failed to load converted PPMX ${file.name}`));
      };
      img.src = url;
    }, 'image/png');
  });
}

function loadImage(file) {
  return new Promise(async (resolve, reject) => {
    const ext = file.name.split('.').pop().toLowerCase();
    if (!file.type.startsWith('image/') && !IMAGE_EXTENSIONS.includes(ext)) {
      reject(new Error(`${file.name} is not an image`));
      return;
    }

    // Handle PPMX files specially
    if (ext === 'ppmx') {
      try {
        const result = await loadPpmx(file);
        resolve(result);
      } catch (err) {
        reject(err);
      }
      return;
    }

    const img = new Image();
    const url = URL.createObjectURL(file);
    img.onload = () => {
      resolve({ img, name: file.name, width: img.width, height: img.height, url });
    };
    img.onerror = () => {
      URL.revokeObjectURL(url);
      reject(new Error(`Failed to load ${file.name}`));
    };
    img.src = url;
  });
}

function checkAndLoadTuple(loadedImages) {
  const aspects = loadedImages.map(img => img.width / img.height);
  const baseAspect = aspects[0];
  const tolerance = 0.01;

  const mismatchIndex = aspects.findIndex((a, i) =>
    i > 0 && Math.abs(a - baseAspect) / Math.max(a, baseAspect) > tolerance
  );

  if (mismatchIndex !== -1) {
    pendingImages = loadedImages;
    const details = loadedImages.map(img =>
      `<strong>${img.modality}</strong>: ${img.width}√ó${img.height} (${(img.width/img.height).toFixed(4)})`
    ).join('<br>');
    errorText.innerHTML = details;
    errorModal.classList.add('active');
    return;
  }

  // Find common name for tuple
  const tupleName = findCommonSubstring(loadedImages.map(img => img.name)) || 'Untitled';

  isMultiTupleMode = false;
  tuples = [{ name: tupleName, images: loadedImages }];
  currentTupleIndex = 0;

  activateViewer(loadedImages, tupleName);
}

function cancelLoad() {
  errorModal.classList.remove('active');
  pendingImages = null;
}

function continueLoad() {
  errorModal.classList.remove('active');
  if (pendingImages) {
    const tupleName = findCommonSubstring(pendingImages.map(img => img.name)) || 'Untitled';
    isMultiTupleMode = false;
    tuples = [{ name: tupleName, images: pendingImages }];
    currentTupleIndex = 0;
    activateViewer(pendingImages, tupleName);
    pendingImages = null;
  }
}

function activateViewer(loadedImages, tupleName, preserveModalityIndex = -1) {
  // Don't revoke URLs for preloaded images
  // Only revoke if they're not in preloaded cache
  for (const img of images) {
    if (!img) continue;
    let isPreloaded = false;
    for (const [_, preloaded] of preloadedTuples.entries()) {
      if (preloaded && preloaded.includes(img)) {
        isPreloaded = true;
        break;
      }
    }
    if (!isPreloaded && img.url) {
      URL.revokeObjectURL(img.url);
    }
  }

  images = loadedImages;

  // Preserve modality index if valid, otherwise find first available
  if (preserveModalityIndex >= 0 && preserveModalityIndex < modalities.length) {
    currentModalityIndex = preserveModalityIndex;
    previousModalityIndex = preserveModalityIndex;
  } else {
    // Find first available modality
    const firstAvailable = images.findIndex(img => img !== undefined);
    currentModalityIndex = firstAvailable >= 0 ? firstAvailable : 0;
    previousModalityIndex = currentModalityIndex;
  }

  zoom = 1;
  panX = panY = 0;
  isReset = false;

  dropzone.classList.add('hidden');
  viewer.classList.add('active');
  info.classList.remove('hidden');
  floatingPanel.classList.add('active');

  // Build modality selector buttons
  buildModalitySelector();

  // Compute and set fixed height for info bar based on all filenames
  computeInfoBarHeight(loadedImages, tupleName);

  // Build or update carousel (only in multi-tuple/dir mode)
  if (isMultiTupleMode && carousel.children.length === 0) {
    buildCarousel();
  } else {
    updateCarouselSelection();
  }

  render();
}

// Compute the max height needed for the info bar across all modalities in the tuple
function computeInfoBarHeight(loadedImages, tupleName) {
  // Reset to auto height first so we can measure
  info.style.height = 'auto';

  let maxHeight = 0;
  const originalNameText = statusName.textContent;
  const originalInfoText = statusInfo.textContent;

  // Measure height for each filename (skip undefined/missing)
  for (const img of loadedImages) {
    if (!img) continue;  // Skip missing modalities
    let nameText = `${img.name} (${img.width}√ó${img.height})`;
    if (isMultiTupleMode) {
      nameText = `[${currentTupleIndex + 1}/${tuples.length}] ` + nameText;
    }
    statusName.textContent = nameText;
    statusInfo.textContent = 'Zoom: 1.0√ó';

    // Force layout recalculation
    const height = info.offsetHeight;
    if (height > maxHeight) {
      maxHeight = height;
    }
  }

  // Also measure "not available" text
  let notAvailText = `Modality: not available`;
  if (isMultiTupleMode) {
    notAvailText = `[${currentTupleIndex + 1}/${tuples.length}] ` + notAvailText;
  }
  statusName.textContent = notAvailText;
  statusInfo.textContent = 'Zoom: 1.0√ó';
  const notAvailHeight = info.offsetHeight;
  if (notAvailHeight > maxHeight) {
    maxHeight = notAvailHeight;
  }

  // Restore original text
  statusName.textContent = originalNameText;
  statusInfo.textContent = originalInfoText;

  // Set fixed height
  info.style.height = maxHeight + 'px';
}

// Recompute info bar height on window resize
let resizeTimeout = null;
window.addEventListener('resize', () => {
  if (modalities.length === 0) return;

  // Debounce resize events
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    const tupleName = isMultiTupleMode ? tuples[currentTupleIndex].name : '';
    computeInfoBarHeight(images, tupleName);
  }, 100);
});

function buildModalitySelector() {
  modalitySelector.innerHTML = '';

  // Show/hide crop and delete actions in floating panel based on voting mode
  if (votingEnabled && isMultiTupleMode) {
    fpActions.classList.remove('hidden');
  } else {
    fpActions.classList.add('hidden');
  }

  // Build buttons for all modalities (index = display position)
  modalities.forEach((modalityName, idx) => {
    const btn = document.createElement('button');
    btn.className = 'modality-btn';
    btn.textContent = `${idx + 1}: ${modalityName}`;
    btn.style.background = modalityColors[idx];
    btn.dataset.index = idx;

    // Mark as unavailable if missing
    const hasImage = images[idx] !== undefined;
    if (!hasImage) {
      btn.classList.add('unavailable');
    }

    btn.addEventListener('click', () => {
      if (currentModalityIndex !== idx) {
        previousModalityIndex = currentModalityIndex;
        currentModalityIndex = idx;
        render();
      }
    });

    modalitySelector.appendChild(btn);
  });

  updateModalitySelector();
}

// Move current modality left or right in the order
function moveCurrentModality(direction) {
  if (modalities.length < 2) return;

  const currentPos = currentModalityIndex;
  const newPos = currentPos + direction;

  // Check bounds
  if (newPos < 0 || newPos >= modalities.length) return;

  // Swap in images array
  const tempImg = images[currentPos];
  images[currentPos] = images[newPos];
  images[newPos] = tempImg;

  // Swap in modalityColors array
  const tempColor = modalityColors[currentPos];
  modalityColors[currentPos] = modalityColors[newPos];
  modalityColors[newPos] = tempColor;

  // Swap in modalities array
  const tempMod = modalities[currentPos];
  modalities[currentPos] = modalities[newPos];
  modalities[newPos] = tempMod;

  // Note: We do NOT swap in tuple.imageData because it's a sparse array
  // with objects that have their own 'modality' field. The carousel and
  // loading code look up images by modality name, not by array index.

  // Update winners to reflect swapped indices
  if (votingEnabled) {
    const newWinners = new Map();
    for (const [tupleIndex, winnerIdx] of winners) {
      if (winnerIdx === currentPos) {
        newWinners.set(tupleIndex, newPos);
      } else if (winnerIdx === newPos) {
        newWinners.set(tupleIndex, currentPos);
      } else {
        newWinners.set(tupleIndex, winnerIdx);
      }
    }
    winners = newWinners;
    // Save updated winners
    saveResults();
  }

  // Update currentModalityIndex to follow the moved modality
  currentModalityIndex = newPos;

  // Clear preloaded tuples since order changed
  for (const [_, imgs] of preloadedTuples.entries()) {
    if (imgs) imgs.forEach(img => { if (img && img.url) URL.revokeObjectURL(img.url); });
  }
  preloadedTuples.clear();

  // Rebuild UI
  buildModalitySelector();
  if (isMultiTupleMode) {
    rebuildCarouselThumbnails();
  }
  render();
}

function updateModalitySelector() {
  // Calculate win counts per modality
  const winCounts = new Array(modalities.length).fill(0);
  if (votingEnabled) {
    for (const [_, modalityIdx] of winners) {
      if (modalityIdx >= 0 && modalityIdx < winCounts.length) {
        winCounts[modalityIdx]++;
      }
    }
  }

  const buttons = modalitySelector.querySelectorAll('.modality-btn');
  buttons.forEach((btn) => {
    const idx = parseInt(btn.dataset.index);
    if (idx === currentModalityIndex) {
      btn.classList.add('active');
      btn.classList.remove('inactive');
    } else {
      btn.classList.remove('active');
      btn.classList.add('inactive');
    }

    // Update button text with win count if voting enabled and has wins
    const modalityName = modalities[idx];
    if (votingEnabled && winCounts[idx] > 0) {
      btn.textContent = `${idx + 1}: ${modalityName} (${winCounts[idx]})`;
    } else {
      btn.textContent = `${idx + 1}: ${modalityName}`;
    }
  });

  // Update reorder button states
  reorderLeftBtn.disabled = currentModalityIndex <= 0;
  reorderRightBtn.disabled = currentModalityIndex >= modalities.length - 1;
}


// Carousel functions
async function buildCarousel() {
  carousel.innerHTML = '';
  carousel.style.width = CAROUSEL_WIDTH + 'px';

  if (!isMultiTupleMode || tuples.length <= 1) {
    carousel.classList.remove('active');
    carouselResize.classList.remove('active');
    return;
  }

  carousel.classList.add('active');
  carouselResize.classList.add('active');
  carouselResize.style.left = (CAROUSEL_WIDTH - 4) + 'px';

  // Count total actual images (not placeholders)
  let totalThumbs = 0;
  for (const tuple of tuples) {
    totalThumbs += tuple.imageData.length;
  }
  let loadedThumbs = 0;

  // Count how many are already cached
  let cachedCount = 0;
  for (const tuple of tuples) {
    for (const imgData of tuple.imageData) {
      if (thumbnailCache.has(imgData.file)) cachedCount++;
    }
  }

  // Only show progress bar if we need to generate thumbnails
  const needsGeneration = cachedCount < totalThumbs;
  if (needsGeneration) {
    progressContainer.classList.add('active');
    progressText.textContent = 'Generating thumbnails...';
    progressFill.style.width = '0%';
  }

  // Build all rows first (with placeholder thumbs for missing modalities)
  const thumbElements = [];  // Array of {thumb, file, tupleIdx, modIdx}

  // Helper to find image data for a specific modality in a tuple
  function findImageForModality(tuple, modalityName) {
    return tuple.imageData.find(img => img.modality === modalityName);
  }

  for (let tupleIdx = 0; tupleIdx < tuples.length; tupleIdx++) {
    const tuple = tuples[tupleIdx];
    const row = document.createElement('div');
    row.className = 'carousel-row';
    row.dataset.tupleIndex = tupleIdx;

    // Iterate over all modalities (not just tuple.imageData)
    for (let modIdx = 0; modIdx < modalities.length; modIdx++) {
      const modalityName = modalities[modIdx];
      const imgData = findImageForModality(tuple, modalityName);

      // Create container for thumbnail + winner indicator
      const container = document.createElement('div');
      container.className = 'carousel-thumb-container';
      container.style.width = CAROUSEL_THUMB_SIZE + 'px';
      container.style.height = CAROUSEL_THUMB_SIZE + 'px';

      if (imgData) {
        // Normal thumbnail
        const thumb = document.createElement('img');
        thumb.className = 'carousel-thumb';
        thumb.style.width = CAROUSEL_THUMB_SIZE + 'px';
        thumb.style.height = CAROUSEL_THUMB_SIZE + 'px';
        thumb.dataset.tupleIndex = tupleIdx;
        thumb.dataset.modalityIndex = modIdx;
        thumb.dataset.modality = modalityName;

        const file = imgData.file;

        // If cached, set immediately
        if (thumbnailCache.has(file)) {
          thumb.src = thumbnailCache.get(file);
          loadedThumbs++;
        } else {
          // Queue for sequential generation
          thumbElements.push({ thumb, file, tupleIdx, modIdx });
        }

        // Click handler
        thumb.addEventListener('click', (e) => {
          e.stopPropagation();
          const ti = parseInt(thumb.dataset.tupleIndex);
          const mi = parseInt(thumb.dataset.modalityIndex);
          goToTupleAndModality(ti, mi);
        });

        container.appendChild(thumb);
      } else {
        // Placeholder for missing modality
        const placeholder = document.createElement('div');
        placeholder.className = 'carousel-thumb placeholder';
        placeholder.style.width = CAROUSEL_THUMB_SIZE + 'px';
        placeholder.style.height = CAROUSEL_THUMB_SIZE + 'px';
        placeholder.dataset.tupleIndex = tupleIdx;
        placeholder.dataset.modalityIndex = modIdx;
        placeholder.dataset.modality = modalityName;
        placeholder.title = `${modalityName} not available`;

        // Click handler - navigate to tuple (will fallback to available modality)
        placeholder.addEventListener('click', (e) => {
          e.stopPropagation();
          const ti = parseInt(placeholder.dataset.tupleIndex);
          const mi = parseInt(placeholder.dataset.modalityIndex);
          goToTupleAndModality(ti, mi);
        });

        container.appendChild(placeholder);
      }

      // Add winner indicator if voting is enabled
      if (votingEnabled) {
        const indicator = document.createElement('div');
        indicator.className = 'winner-indicator';
        indicator.dataset.tupleIndex = tupleIdx;
        indicator.dataset.modalityIndex = modIdx;

        // Check if this is the winner
        if (winners.get(tupleIdx) === modIdx) {
          indicator.classList.add('winner');
        }

        indicator.addEventListener('click', (e) => {
          e.stopPropagation();
          toggleWinner(tupleIdx, modIdx);
        });

        container.appendChild(indicator);
      }

      row.appendChild(container);
    }

    // Click on row
    row.addEventListener('click', () => {
      const ti = parseInt(row.dataset.tupleIndex);
      if (ti !== currentTupleIndex) {
        loadTuple(ti);
      }
    });

    carousel.appendChild(row);
  }

  updateCarouselSelection();

  // Generate uncached thumbnails sequentially (top to bottom)
  // Yield after each thumbnail to keep UI responsive during zoom/pan
  async function generateThumbnailsSequentially() {
    for (const { thumb, file, tupleIdx, modIdx } of thumbElements) {
      // Yield before each thumbnail to allow UI updates
      await new Promise(resolve => setTimeout(resolve, 0));

      try {
        const dataUrl = await generateThumbnail(file, CAROUSEL_THUMB_SIZE * 2);
        thumbnailCache.set(file, dataUrl);
        thumb.src = dataUrl;
        loadedThumbs++;

        const progress = Math.round((loadedThumbs / totalThumbs) * 100);
        progressFill.style.width = progress + '%';
        progressText.textContent = `Generating thumbnails... ${loadedThumbs}/${totalThumbs}`;
      } catch (err) {
        console.warn(`Failed to generate thumbnail for tuple ${tupleIdx}, mod ${modIdx}:`, err);
        loadedThumbs++;
      }
    }

    // Done - hide progress bar
    progressContainer.classList.remove('active');
  }

  if (thumbElements.length > 0) {
    generateThumbnailsSequentially();
  } else {
    progressContainer.classList.remove('active');
  }
}

function rebuildCarouselThumbnails() {
  // Rebuild carousel after reordering
  if (!isMultiTupleMode) return;
  buildCarousel();
}

function updateCarouselSelection() {
  if (!isMultiTupleMode) return;

  // Get current modality name from modalities array
  const currentModality = modalities[currentModalityIndex];

  const rows = carousel.querySelectorAll('.carousel-row');
  rows.forEach((row, rowIdx) => {
    if (rowIdx === currentTupleIndex) {
      row.classList.add('current');
    } else {
      row.classList.remove('current');
    }

    // Find thumbs inside containers
    const containers = row.querySelectorAll('.carousel-thumb-container');
    containers.forEach((container) => {
      const thumb = container.querySelector('.carousel-thumb');
      if (!thumb) return;

      const thumbModality = thumb.dataset.modality;

      // Active means it's in the current tuple
      if (rowIdx === currentTupleIndex) {
        thumb.classList.add('active');
      } else {
        thumb.classList.remove('active');
      }

      // Selected means it's the current modality in current tuple
      if (rowIdx === currentTupleIndex && thumbModality === currentModality) {
        thumb.classList.add('selected');
      } else {
        thumb.classList.remove('selected');
      }
    });
  });

  scrollCarouselToCurrentTuple();
}

function scrollCarouselToCurrentTuple() {
  if (!isMultiTupleMode) return;

  const rows = carousel.querySelectorAll('.carousel-row');
  if (rows.length === 0 || currentTupleIndex >= rows.length) return;

  const currentRow = rows[currentTupleIndex];

  // Calculate where the row should be (centered)
  const carouselHeight = carousel.clientHeight;
  const rowHeight = currentRow.offsetHeight;
  const rowTop = currentRow.offsetTop;

  const targetScroll = rowTop - (carouselHeight / 2) + (rowHeight / 2);

  carousel.scrollTo({
    top: Math.max(0, targetScroll),
    behavior: 'smooth'
  });
}

async function goToTupleAndModality(tupleIdx, modalityIdx) {
  if (tupleIdx === currentTupleIndex) {
    // Same tuple, just switch modality
    if (modalityIdx !== currentModalityIndex) {
      previousModalityIndex = currentModalityIndex;
      currentModalityIndex = modalityIdx;
      render();
      updateCarouselSelection();
    }
  } else {
    // Different tuple - load it with the specified modality
    currentModalityIndex = modalityIdx;
    await loadTuple(tupleIdx);
  }
}

function render() {
  if (modalities.length === 0) return;

  // Update modality selector
  updateModalitySelector();

  // Update carousel selection
  if (isMultiTupleMode) {
    updateCarouselSelection();
  }

  const currentImage = images[currentModalityIndex];
  const modalityName = modalities[currentModalityIndex];

  // Check if current modality is missing
  if (!currentImage) {
    // Show "not available" placeholder
    const carouselOffset = isMultiTupleMode ? CAROUSEL_WIDTH : 0;

    // Update status (two-part layout)
    let nameText = `${modalityName}: not available`;
    if (isMultiTupleMode) {
      nameText = `[${currentTupleIndex + 1}/${tuples.length}] ` + nameText;
    }
    statusName.textContent = nameText;
    statusInfo.textContent = `Zoom: ${zoom.toFixed(1)}√ó`;

    // Draw placeholder on canvas
    requestAnimationFrame(() => {
      canvas.width = 400;
      canvas.height = 200;
      ctx.fillStyle = '#333';
      ctx.fillRect(0, 0, 400, 200);
      ctx.fillStyle = '#666';
      ctx.font = 'bold 48px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('‚úï', 200, 90);
      ctx.font = '16px sans-serif';
      ctx.fillStyle = '#888';
      ctx.fillText('Image not available', 200, 140);

      canvas.style.width = '400px';
      canvas.style.height = '200px';

      const centerOffsetX = carouselOffset / 2;
      canvas.style.transform = `translate(calc(-50% + ${centerOffsetX}px), -50%)`;

      // Clear minimap preview (no image to show)
      thumbCanvas.width = 0;
      thumbCanvas.height = 0;
      thumbViewport.style.display = 'none';
    });
    return;
  }

  const { img, name, width, height } = currentImage;

  // Update status (two-part layout)
  let nameText = `${name} (${width}√ó${height})`;
  if (isMultiTupleMode) {
    nameText = `[${currentTupleIndex + 1}/${tuples.length}] ` + nameText;
  }
  statusName.textContent = nameText;
  statusInfo.textContent = `Zoom: ${zoom.toFixed(1)}√ó`;

  // Use requestAnimationFrame to ensure layout is updated before measuring
  requestAnimationFrame(() => {
    // Fit to viewer (account for carousel width)
    const carouselOffset = isMultiTupleMode ? CAROUSEL_WIDTH : 0;
    const vw = viewer.clientWidth - carouselOffset;
    const vh = viewer.clientHeight;
    const baseScale = Math.min(vw / width, vh / height);
    const scale = baseScale * zoom;

    canvas.width = width;
    canvas.height = height;
    ctx.drawImage(img, 0, 0);

    const displayW = width * scale;
    const displayH = height * scale;

    canvas.style.width = displayW + 'px';
    canvas.style.height = displayH + 'px';

    // Offset canvas center by half carousel width when carousel is visible
    const centerOffsetX = carouselOffset / 2;
    canvas.style.transform = `translate(calc(-50% + ${panX + centerOffsetX}px), calc(-50% + ${panY}px))`;

    // Update thumbnail
    renderThumbnail(img, width, height, vw, vh, baseScale);

    // Update crop overlay if active
    if (cropMode) {
      const vp = getCropViewport();
      if (vp) renderCropOverlay(vp);
    }
  });
}

function renderThumbnail(img, imgW, imgH, viewerW, viewerH, baseScale) {
  // Always render the preview thumbnail
  const thumbScale = Math.min(THUMB_MAX_SIZE / imgW, THUMB_MAX_SIZE / imgH);
  const thumbW = Math.round(imgW * thumbScale);
  const thumbH = Math.round(imgH * thumbScale);

  thumbCanvas.width = thumbW;
  thumbCanvas.height = thumbH;
  thumbCtx.drawImage(img, 0, 0, thumbW, thumbH);

  // Show viewport rectangle only when zoomed in
  const canvasOffsetX = thumbCanvas.offsetLeft;
  if (zoom <= 1.05) {
    thumbViewport.style.display = 'none';
  } else {
    thumbViewport.style.display = 'block';

    const scale = baseScale * zoom;
    const visibleW = viewerW / scale;
    const visibleH = viewerH / scale;

    const centerX = imgW / 2 - panX / scale;
    const centerY = imgH / 2 - panY / scale;

    const vpLeft = centerX - visibleW / 2;
    const vpTop = centerY - visibleH / 2;

    const vpX = vpLeft * thumbScale;
    const vpY = vpTop * thumbScale;
    const vpW = visibleW * thumbScale;
    const vpH = visibleH * thumbScale;

    thumbViewport.style.left = (canvasOffsetX + Math.max(0, vpX)) + 'px';
    thumbViewport.style.top = Math.max(0, vpY) + 'px';
    thumbViewport.style.width = Math.min(vpW, thumbW - Math.max(0, vpX)) + 'px';
    thumbViewport.style.height = Math.min(vpH, thumbH - Math.max(0, vpY)) + 'px';
  }
}

// =========================================================================
// Crop Tool
// =========================================================================

const CROP_HANDLE_SIZE = 10;
const MIN_CROP_PX = 4;

let cropRect = null;  // {x, y, w, h} in image pixels
let cropOverlayEl = null;
let cropRectEl = null;
let cropToolbarEl = null;
let cropDimEls = [];
let cropHandleEls = new Map();
let cropIsDrawing = false;
let cropIsMoving = false;
let cropIsResizing = false;
let cropActiveHandle = null;
let cropDrawStartImg = null;
let cropMoveStartImg = null;
let cropMoveStartRect = null;

function getCropViewport() {
  const currentImage = images[currentModalityIndex];
  if (!currentImage) return null;
  const carouselOffset = isMultiTupleMode ? CAROUSEL_WIDTH : 0;
  return {
    viewerEl: viewer,
    zoom, panX, panY,
    imgW: currentImage.width,
    imgH: currentImage.height,
    carouselOffset
  };
}

function getCropBaseScale(vp) {
  const rect = vp.viewerEl.getBoundingClientRect();
  const vw = rect.width - vp.carouselOffset;
  const vh = rect.height;
  return Math.min(vw / vp.imgW, vh / vp.imgH);
}

function screenToImage(screenX, screenY, vp) {
  const rect = vp.viewerEl.getBoundingClientRect();
  const vw = rect.width - vp.carouselOffset;
  const vh = rect.height;
  const displayScale = getCropBaseScale(vp) * vp.zoom;

  const viewerCenterX = rect.left + vp.carouselOffset + vw / 2;
  const viewerCenterY = rect.top + vh / 2;

  const imageX = (screenX - viewerCenterX - vp.panX) / displayScale + vp.imgW / 2;
  const imageY = (screenY - viewerCenterY - vp.panY) / displayScale + vp.imgH / 2;

  return {
    x: Math.max(0, Math.min(vp.imgW, Math.round(imageX))),
    y: Math.max(0, Math.min(vp.imgH, Math.round(imageY)))
  };
}

function imageToScreen(imgX, imgY, vp) {
  const rect = vp.viewerEl.getBoundingClientRect();
  const vw = rect.width - vp.carouselOffset;
  const vh = rect.height;
  const displayScale = getCropBaseScale(vp) * vp.zoom;

  const viewerCenterX = rect.left + vp.carouselOffset + vw / 2;
  const viewerCenterY = rect.top + vh / 2;

  return {
    x: (imgX - vp.imgW / 2) * displayScale + vp.panX + viewerCenterX,
    y: (imgY - vp.imgH / 2) * displayScale + vp.panY + viewerCenterY
  };
}

function getCursorForHandle(id) {
  const map = {
    nw: 'nw-resize', n: 'n-resize', ne: 'ne-resize', e: 'e-resize',
    se: 'se-resize', s: 's-resize', sw: 'sw-resize', w: 'w-resize'
  };
  return map[id];
}

function createCropOverlay() {
  cropOverlayEl = document.createElement('div');
  cropOverlayEl.id = 'crop-overlay';
  viewer.appendChild(cropOverlayEl);

  // 4 dim regions
  for (let i = 0; i < 4; i++) {
    const dim = document.createElement('div');
    dim.className = 'crop-dim';
    dim.style.display = 'none';
    cropOverlayEl.appendChild(dim);
    cropDimEls.push(dim);
  }

  // Crop rectangle
  cropRectEl = document.createElement('div');
  cropRectEl.className = 'crop-rect';
  cropRectEl.style.display = 'none';
  cropOverlayEl.appendChild(cropRectEl);

  // Resize handles
  const handles = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'];
  for (const id of handles) {
    const handle = document.createElement('div');
    handle.className = 'crop-handle';
    handle.dataset.handle = id;
    handle.style.cursor = getCursorForHandle(id);
    cropOverlayEl.appendChild(handle);
    cropHandleEls.set(id, handle);
  }

  // Toolbar
  cropToolbarEl = document.createElement('div');
  cropToolbarEl.className = 'crop-toolbar';
  cropToolbarEl.innerHTML = `
    <button class="crop-toolbar-btn crop-confirm" title="Confirm crop (Enter)">&#10003; Crop</button>
    <button class="crop-toolbar-btn crop-cancel" title="Cancel (Escape)">&#10005;</button>
  `;
  cropOverlayEl.appendChild(cropToolbarEl);

  cropToolbarEl.querySelector('.crop-confirm').addEventListener('mousedown', (e) => {
    e.stopPropagation();
    e.preventDefault();
    confirmCrop();
  });
  cropToolbarEl.querySelector('.crop-cancel').addEventListener('mousedown', (e) => {
    e.stopPropagation();
    e.preventDefault();
    exitCropMode(true);
  });

  setCropHandlesVisible(false);
  cropToolbarEl.style.display = 'none';
}

function destroyCropOverlay() {
  if (cropOverlayEl && cropOverlayEl.parentNode) {
    cropOverlayEl.parentNode.removeChild(cropOverlayEl);
  }
  cropOverlayEl = null;
  cropRectEl = null;
  cropToolbarEl = null;
  cropDimEls = [];
  cropHandleEls.clear();
}

function setCropHandlesVisible(visible) {
  for (const el of cropHandleEls.values()) {
    el.style.display = visible ? 'block' : 'none';
  }
}

function enterCropMode() {
  if (cropMode) return;
  cropMode = true;
  cropRect = null;
  cropIsDrawing = false;
  cropIsMoving = false;
  cropIsResizing = false;
  createCropOverlay();
  dbg('Entered crop mode');
}

function exitCropMode(cancel) {
  cropMode = false;
  cropRect = null;
  cropIsDrawing = false;
  cropIsMoving = false;
  cropIsResizing = false;
  cropActiveHandle = null;
  destroyCropOverlay();
  cropBtn.classList.remove('active');
  dbg('Exited crop mode', cancel ? '(cancelled)' : '');
}

async function confirmCrop() {
  if (!cropRect || cropRect.w < MIN_CROP_PX || cropRect.h < MIN_CROP_PX) return;

  dbg('Confirming crop:', cropRect);

  try {
    await saveCropFiles(cropRect);
    exitCropMode(false);
  } catch (err) {
    console.error('Crop failed:', err);
    alert('Crop failed: ' + err.message);
  }
}

async function getNextCropNumber(dirHandle, tupleName) {
  try {
    const escaped = tupleName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const cropPattern = new RegExp(`^${escaped}_crop(\\d+)\\.`);
    let maxNum = 0;
    for await (const entry of dirHandle.values()) {
      if (entry.kind === 'file') {
        const match = entry.name.match(cropPattern);
        if (match) maxNum = Math.max(maxNum, parseInt(match[1], 10));
      }
    }
    return maxNum + 1;
  } catch {
    return 1;
  }
}

async function cropImageToBlob(imageObj, rect) {
  const cropCanvas = document.createElement('canvas');
  cropCanvas.width = rect.w;
  cropCanvas.height = rect.h;
  const cropCtx = cropCanvas.getContext('2d');
  cropCtx.drawImage(imageObj.img, rect.x, rect.y, rect.w, rect.h, 0, 0, rect.w, rect.h);
  return new Promise(resolve => cropCanvas.toBlob(resolve, 'image/png'));
}

async function saveCropFiles(rect) {
  const tuple = tuples[currentTupleIndex];
  if (!tuple) throw new Error('No current tuple');

  const tupleName = tuple.name;

  // Find first modality dir to determine crop number
  const firstModality = modalities.find(m => modalityDirHandles.has(m));
  if (!firstModality) throw new Error('No directory handles available');

  const cropNum = await getNextCropNumber(modalityDirHandles.get(firstModality), tupleName);
  const cropSuffix = `_crop${String(cropNum).padStart(2, '0')}`;
  const outputName = `${tupleName}${cropSuffix}.png`;

  dbg('Saving crop as', outputName);

  let savedCount = 0;
  for (let i = 0; i < modalities.length; i++) {
    const img = images[i];
    if (!img) continue;
    const dirHandle = modalityDirHandles.get(modalities[i]);
    if (!dirHandle) continue;

    // Clamp crop rect to image bounds
    const clampedRect = {
      x: Math.max(0, Math.min(rect.x, img.width - 1)),
      y: Math.max(0, Math.min(rect.y, img.height - 1)),
      w: Math.min(rect.w, img.width - Math.max(0, rect.x)),
      h: Math.min(rect.h, img.height - Math.max(0, rect.y))
    };
    if (clampedRect.w <= 0 || clampedRect.h <= 0) continue;

    try {
      const blob = await cropImageToBlob(img, clampedRect);
      const fileHandle = await dirHandle.getFileHandle(outputName, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(blob);
      await writable.close();
      savedCount++;
      dbg('Saved crop to', modalities[i] + '/' + outputName);
    } catch (err) {
      console.warn(`Failed to save crop to ${modalities[i]}:`, err);
    }
  }

  if (savedCount === 0) throw new Error('Failed to save any crop files');
  dbg('Crop saved to', savedCount, 'modalities. Poller will detect new tuple.');
}

// Crop mouse handlers - return true if event was consumed
function handleCropMouseDown(e) {
  if (!cropOverlayEl) return false;
  const vp = getCropViewport();
  if (!vp) return false;

  const target = e.target;

  // Check handle
  if (target.classList.contains('crop-handle') && target.dataset.handle) {
    e.preventDefault();
    e.stopPropagation();
    cropIsResizing = true;
    cropActiveHandle = target.dataset.handle;
    return true;
  }

  // Check toolbar
  if (target.closest('.crop-toolbar')) return true;

  // Check inside crop rect (to move)
  if (cropRect && cropRectEl) {
    const screenPos = imageToScreen(cropRect.x, cropRect.y, vp);
    const screenEnd = imageToScreen(cropRect.x + cropRect.w, cropRect.y + cropRect.h, vp);
    const viewerRect = vp.viewerEl.getBoundingClientRect();
    const sx = screenPos.x - viewerRect.left;
    const sy = screenPos.y - viewerRect.top;
    const ex = screenEnd.x - viewerRect.left;
    const ey = screenEnd.y - viewerRect.top;

    if (e.offsetX >= sx && e.offsetX <= ex && e.offsetY >= sy && e.offsetY <= ey) {
      e.preventDefault();
      e.stopPropagation();
      cropIsMoving = true;
      cropMoveStartImg = screenToImage(e.clientX, e.clientY, vp);
      cropMoveStartRect = { ...cropRect };
      return true;
    }
  }

  // Start drawing new crop rectangle
  e.preventDefault();
  e.stopPropagation();
  cropIsDrawing = true;
  cropDrawStartImg = screenToImage(e.clientX, e.clientY, vp);
  cropRect = { x: cropDrawStartImg.x, y: cropDrawStartImg.y, w: 0, h: 0 };
  setCropHandlesVisible(false);
  if (cropToolbarEl) cropToolbarEl.style.display = 'none';
  return true;
}

function handleCropMouseMove(e) {
  const vp = getCropViewport();
  if (!vp) return false;

  if (cropIsDrawing && cropDrawStartImg) {
    e.preventDefault();
    const imgPos = screenToImage(e.clientX, e.clientY, vp);
    const x1 = Math.min(cropDrawStartImg.x, imgPos.x);
    const y1 = Math.min(cropDrawStartImg.y, imgPos.y);
    const x2 = Math.max(cropDrawStartImg.x, imgPos.x);
    const y2 = Math.max(cropDrawStartImg.y, imgPos.y);
    cropRect = {
      x: Math.max(0, x1),
      y: Math.max(0, y1),
      w: Math.min(vp.imgW, x2) - Math.max(0, x1),
      h: Math.min(vp.imgH, y2) - Math.max(0, y1)
    };
    renderCropOverlay(vp);
    return true;
  }

  if (cropIsMoving && cropMoveStartImg && cropMoveStartRect) {
    e.preventDefault();
    const imgPos = screenToImage(e.clientX, e.clientY, vp);
    const dx = imgPos.x - cropMoveStartImg.x;
    const dy = imgPos.y - cropMoveStartImg.y;
    let newX = cropMoveStartRect.x + dx;
    let newY = cropMoveStartRect.y + dy;
    newX = Math.max(0, Math.min(vp.imgW - cropMoveStartRect.w, newX));
    newY = Math.max(0, Math.min(vp.imgH - cropMoveStartRect.h, newY));
    cropRect = { x: Math.round(newX), y: Math.round(newY), w: cropMoveStartRect.w, h: cropMoveStartRect.h };
    renderCropOverlay(vp);
    return true;
  }

  if (cropIsResizing && cropActiveHandle && cropRect) {
    e.preventDefault();
    const imgPos = screenToImage(e.clientX, e.clientY, vp);
    const r = { ...cropRect };

    if (cropActiveHandle.includes('n')) {
      const newTop = Math.max(0, Math.min(r.y + r.h - MIN_CROP_PX, imgPos.y));
      r.h = r.y + r.h - newTop;
      r.y = newTop;
    }
    if (cropActiveHandle.includes('s')) {
      r.h = Math.max(MIN_CROP_PX, Math.min(vp.imgH - r.y, imgPos.y - r.y));
    }
    if (cropActiveHandle.includes('w')) {
      const newLeft = Math.max(0, Math.min(r.x + r.w - MIN_CROP_PX, imgPos.x));
      r.w = r.x + r.w - newLeft;
      r.x = newLeft;
    }
    if (cropActiveHandle.includes('e')) {
      r.w = Math.max(MIN_CROP_PX, Math.min(vp.imgW - r.x, imgPos.x - r.x));
    }

    cropRect = { x: Math.round(r.x), y: Math.round(r.y), w: Math.round(r.w), h: Math.round(r.h) };
    renderCropOverlay(vp);
    return true;
  }

  return false;
}

function handleCropMouseUp(e) {
  const wasDrawing = cropIsDrawing;
  const wasActive = cropIsDrawing || cropIsMoving || cropIsResizing;
  cropIsDrawing = false;
  cropIsMoving = false;
  cropIsResizing = false;
  cropActiveHandle = null;
  cropDrawStartImg = null;
  cropMoveStartImg = null;
  cropMoveStartRect = null;

  const vp = getCropViewport();

  if (wasActive && cropRect && cropRect.w >= MIN_CROP_PX && cropRect.h >= MIN_CROP_PX) {
    setCropHandlesVisible(true);
    if (cropToolbarEl) cropToolbarEl.style.display = 'flex';
    if (vp) renderCropOverlay(vp);
  } else if (wasDrawing) {
    cropRect = null;
    setCropHandlesVisible(false);
    if (cropToolbarEl) cropToolbarEl.style.display = 'none';
    if (vp) renderCropOverlay(vp);
  }
  return wasActive;
}

function handleCropKeyDown(e) {
  if (e.code === 'Enter' && cropRect && cropRect.w >= MIN_CROP_PX && cropRect.h >= MIN_CROP_PX) {
    e.preventDefault();
    confirmCrop();
    return true;
  }
  if (e.code === 'Escape') {
    e.preventDefault();
    exitCropMode(true);
    return true;
  }
  // Allow arrow keys for modality switching while in crop mode
  if (e.code === 'ArrowLeft' || e.code === 'ArrowRight') return false;
  // Block other navigation keys
  if (e.code === 'ArrowUp' || e.code === 'ArrowDown' || e.code === 'Space') {
    e.preventDefault();
    return true;
  }
  return false;
}

function renderCropOverlay(vp) {
  if (!cropOverlayEl || !cropRectEl || !cropRect) {
    if (cropOverlayEl) cropOverlayEl.style.display = cropMode ? 'block' : 'none';
    for (const dim of cropDimEls) dim.style.display = 'none';
    if (cropRectEl) cropRectEl.style.display = 'none';
    setCropHandlesVisible(false);
    if (cropToolbarEl) cropToolbarEl.style.display = 'none';
    return;
  }

  cropOverlayEl.style.display = 'block';

  const viewerRect = vp.viewerEl.getBoundingClientRect();
  const topLeft = imageToScreen(cropRect.x, cropRect.y, vp);
  const bottomRight = imageToScreen(cropRect.x + cropRect.w, cropRect.y + cropRect.h, vp);

  const sx = topLeft.x - viewerRect.left;
  const sy = topLeft.y - viewerRect.top;
  const ex = bottomRight.x - viewerRect.left;
  const ey = bottomRight.y - viewerRect.top;
  const sw = ex - sx;
  const sh = ey - sy;
  const ow = viewerRect.width;
  const oh = viewerRect.height;

  // Dim overlays (top, bottom, left, right)
  if (cropDimEls.length >= 4) {
    cropDimEls[0].style.cssText = `display:block; left:0; top:0; width:${ow}px; height:${Math.max(0, sy)}px;`;
    cropDimEls[1].style.cssText = `display:block; left:0; top:${ey}px; width:${ow}px; height:${Math.max(0, oh - ey)}px;`;
    cropDimEls[2].style.cssText = `display:block; left:0; top:${sy}px; width:${Math.max(0, sx)}px; height:${sh}px;`;
    cropDimEls[3].style.cssText = `display:block; left:${ex}px; top:${sy}px; width:${Math.max(0, ow - ex)}px; height:${sh}px;`;
  }

  // Crop rect
  cropRectEl.style.display = 'block';
  cropRectEl.style.left = sx + 'px';
  cropRectEl.style.top = sy + 'px';
  cropRectEl.style.width = sw + 'px';
  cropRectEl.style.height = sh + 'px';

  // Handles
  const hs = CROP_HANDLE_SIZE;
  const hh = hs / 2;
  const positions = {
    nw: { left: sx - hh, top: sy - hh },
    n:  { left: sx + sw / 2 - hh, top: sy - hh },
    ne: { left: ex - hh, top: sy - hh },
    e:  { left: ex - hh, top: sy + sh / 2 - hh },
    se: { left: ex - hh, top: ey - hh },
    s:  { left: sx + sw / 2 - hh, top: ey - hh },
    sw: { left: sx - hh, top: ey - hh },
    w:  { left: sx - hh, top: sy + sh / 2 - hh }
  };

  for (const [id, el] of cropHandleEls) {
    const pos = positions[id];
    el.style.left = pos.left + 'px';
    el.style.top = pos.top + 'px';
    el.style.width = hs + 'px';
    el.style.height = hs + 'px';
  }

  // Toolbar below crop rect
  if (cropToolbarEl && cropToolbarEl.style.display !== 'none') {
    cropToolbarEl.style.left = (sx + sw / 2) + 'px';
    cropToolbarEl.style.top = (ey + 8) + 'px';
  }
}

// Keyboard controls
document.addEventListener('keydown', (e) => {
  // Close help modal on Escape
  if (e.code === 'Escape' && helpModal.classList.contains('active')) {
    closeHelpModal();
    e.preventDefault();
    return;
  }

  if (modalities.length === 0) return;

  // Crop mode key interception
  if (cropMode && handleCropKeyDown(e)) return;

  switch(e.code) {
    case 'Space':
      e.preventDefault();
      if (!spaceDown) {
        spaceDown = true;
        // Flip to previous modality
        const temp = currentModalityIndex;
        currentModalityIndex = previousModalityIndex;
        previousModalityIndex = temp;
        render();
      }
      break;
    case 'ArrowRight':
      e.preventDefault();
      if (currentModalityIndex < modalities.length - 1) {
        previousModalityIndex = currentModalityIndex;
        currentModalityIndex++;
        render();
      }
      break;
    case 'ArrowLeft':
      e.preventDefault();
      if (currentModalityIndex > 0) {
        previousModalityIndex = currentModalityIndex;
        currentModalityIndex--;
        render();
      }
      break;
    case 'BracketLeft':
      e.preventDefault();
      moveCurrentModality(-1);
      break;
    case 'BracketRight':
      e.preventDefault();
      moveCurrentModality(1);
      break;
    case 'ArrowUp':
      e.preventDefault();
      if (isMultiTupleMode && currentTupleIndex > 0) {
        // Throttle when holding key down
        const now = Date.now();
        if (isLoadingTuple || (e.repeat && now - lastKeyNavTime < KEY_NAV_THROTTLE)) break;
        lastKeyNavTime = now;
        isLoadingTuple = true;
        loadTuple(currentTupleIndex - 1).finally(() => { isLoadingTuple = false; });
      }
      break;
    case 'ArrowDown':
      e.preventDefault();
      if (isMultiTupleMode && currentTupleIndex < tuples.length - 1) {
        // Throttle when holding key down
        const now2 = Date.now();
        if (isLoadingTuple || (e.repeat && now2 - lastKeyNavTime < KEY_NAV_THROTTLE)) break;
        lastKeyNavTime = now2;
        isLoadingTuple = true;
        loadTuple(currentTupleIndex + 1).finally(() => { isLoadingTuple = false; });
      }
      break;
    case 'Digit1': case 'Digit2': case 'Digit3': case 'Digit4':
    case 'Digit5': case 'Digit6': case 'Digit7': case 'Digit8': case 'Digit9':
      e.preventDefault();
      const idx = parseInt(e.code.replace('Digit', '')) - 1;
      if (idx < modalities.length && idx !== currentModalityIndex) {
        previousModalityIndex = currentModalityIndex;
        currentModalityIndex = idx;
        render();
      }
      break;
    case 'Enter':
      e.preventDefault();
      if (votingEnabled && isMultiTupleMode) {
        toggleWinner(currentTupleIndex, currentModalityIndex);
      }
      break;
    case 'KeyC':
      e.preventDefault();
      if (cropMode) {
        exitCropMode(true);
      } else if (votingEnabled && isMultiTupleMode) {
        cropBtn.classList.add('active');
        enterCropMode();
      }
      break;
    case 'Delete':
    case 'Backspace':
      e.preventDefault();
      if (votingEnabled && isMultiTupleMode && !cropMode) {
        deleteTupleFiles();
      }
      break;
    case 'KeyR':
    case 'Escape':
      if (e.code === 'Escape' && errorModal.classList.contains('active')) {
        cancelLoad();
        break;
      }
      // If already reset, go back to dropzone
      if (isReset && zoom === 1 && panX === 0 && panY === 0) {
        resetToDropzone();
        break;
      }
      zoom = 1;
      panX = panY = 0;
      isReset = true;
      render();
      break;
  }
});

// Mouse wheel zoom - zoom towards mouse position
viewer.addEventListener('wheel', (e) => {
  // Check if over carousel
  const carouselRect = carousel.getBoundingClientRect();
  if (isMultiTupleMode && e.clientX >= carouselRect.left && e.clientX <= carouselRect.right &&
      e.clientY >= carouselRect.top && e.clientY <= carouselRect.bottom) {
    return;  // Let carousel handle it
  }

  e.preventDefault();
  const delta = e.deltaY > 0 ? 0.97 : 1.03;
  const newZoom = Math.max(0.1, Math.min(50, zoom * delta));

  // Get mouse position relative to viewer center (accounting for carousel)
  const rect = viewer.getBoundingClientRect();
  const carouselOffset = isMultiTupleMode ? CAROUSEL_WIDTH : 0;
  const mouseX = e.clientX - rect.left - carouselOffset - (rect.width - carouselOffset) / 2;
  const mouseY = e.clientY - rect.top - rect.height / 2;

  // Adjust pan so the point under the mouse stays fixed
  const zoomRatio = newZoom / zoom;
  panX = mouseX - (mouseX - panX) * zoomRatio;
  panY = mouseY - (mouseY - panY) * zoomRatio;

  zoom = newZoom;
  isReset = false;
  render();
}, { passive: false });

// Pan with mouse drag
viewer.addEventListener('mousedown', (e) => {
  // Don't start drag if clicking on carousel or floating panel
  if (e.target.closest('#carousel') || e.target.closest('#floating-panel')) return;

  // Crop mode intercepts mouse events
  if (cropMode && handleCropMouseDown(e)) return;

  isDragging = true;
  dragStartX = e.clientX - panX;
  dragStartY = e.clientY - panY;
  viewer.classList.add('dragging');
});

document.addEventListener('mousemove', (e) => {
  if (cropMode && handleCropMouseMove(e)) return;
  if (!isDragging) return;
  panX = e.clientX - dragStartX;
  panY = e.clientY - dragStartY;
  isReset = false;
  render();
});

document.addEventListener('mouseup', (e) => {
  if (cropMode) handleCropMouseUp(e);
  isDragging = false;
  viewer.classList.remove('dragging');
});

// Space bar release - flip back
document.addEventListener('keyup', (e) => {
  if (e.code === 'Space') {
    spaceDown = false;
    if (modalities.length > 0) {
      // Flip back
      const temp = currentModalityIndex;
      currentModalityIndex = previousModalityIndex;
      previousModalityIndex = temp;
      render();
    }
  }
});

// Handle resize - re-render canvas immediately
window.addEventListener('resize', () => {
  if (modalities.length > 0) render();
});

// Carousel mouse wheel scrolling
carousel.addEventListener('wheel', (e) => {
  e.preventDefault();
  e.stopPropagation();
  carousel.scrollTop += e.deltaY;
}, { passive: false });

// Carousel resize handle
let isResizingCarousel = false;
let resizeStartX = 0;
let resizeStartWidth = 0;
let resizeCenterRowFraction = 0;  // Where in the row (0-1) is the viewport center?

carouselResize.addEventListener('mousedown', (e) => {
  e.preventDefault();
  e.stopPropagation();
  isResizingCarousel = true;
  resizeStartX = e.clientX;
  resizeStartWidth = CAROUSEL_WIDTH;
  carouselResize.classList.add('dragging');
  carousel.classList.add('resizing');
  document.body.style.cursor = 'ew-resize';

  // Capture where the viewport center is relative to the current row
  const rows = carousel.querySelectorAll('.carousel-row');
  const currentRow = rows[currentTupleIndex];
  if (currentRow && currentRow.offsetHeight > 0) {
    const viewportCenter = carousel.scrollTop + carousel.clientHeight / 2;
    const rowTop = currentRow.offsetTop;
    // How far into the row is the viewport center? (as fraction of row height)
    resizeCenterRowFraction = (viewportCenter - rowTop) / currentRow.offsetHeight;
  }
});

document.addEventListener('mousemove', (e) => {
  if (!isResizingCarousel) return;

  const delta = e.clientX - resizeStartX;
  const newWidth = Math.max(100, Math.min(500, resizeStartWidth + delta));
  CAROUSEL_WIDTH = newWidth;
  carousel.style.width = CAROUSEL_WIDTH + 'px';
  carouselResize.style.left = (CAROUSEL_WIDTH - 4) + 'px';

  // Recalculate thumbnail size
  updateCarouselThumbSize();

  // Update thumbnail sizes in DOM
  const thumbs = carousel.querySelectorAll('.carousel-thumb');
  thumbs.forEach(thumb => {
    thumb.style.width = CAROUSEL_THUMB_SIZE + 'px';
    thumb.style.height = CAROUSEL_THUMB_SIZE + 'px';
  });

  // Restore scroll so the viewport center stays at the same position in the current row
  const rows = carousel.querySelectorAll('.carousel-row');
  const currentRow = rows[currentTupleIndex];
  if (currentRow) {
    const rowTop = currentRow.offsetTop;
    // The viewport center should be at rowTop + fraction * rowHeight
    const targetViewportCenter = rowTop + resizeCenterRowFraction * currentRow.offsetHeight;
    const newScrollTop = targetViewportCenter - carousel.clientHeight / 2;
    // Clamp to valid range
    const maxScroll = Math.max(0, carousel.scrollHeight - carousel.clientHeight);
    carousel.scrollTop = Math.max(0, Math.min(maxScroll, newScrollTop));
  }

  render();
});

document.addEventListener('mouseup', () => {
  if (isResizingCarousel) {
    isResizingCarousel = false;
    carouselResize.classList.remove('dragging');
    carousel.classList.remove('resizing');
    document.body.style.cursor = '';
  }
});
</script>
</body>
</html>
